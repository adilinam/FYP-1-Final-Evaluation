/*
 * generated by Xtext
 */
package org.eclipse.qvto.examples.xtext.qvtoperational.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;

import org.eclipse.qvto.examples.xtext.imperativeocl.services.ImperativeOCLGrammarAccess;
import org.eclipse.ocl.xtext.essentialocl.services.EssentialOCLGrammarAccess;
import org.eclipse.ocl.xtext.base.services.BaseGrammarAccess;

@Singleton
public class QVTOperationalGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class TopLevelCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TopLevelCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cOwnedImportsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cOwnedImportsImportCSParserRuleCall_0_0 = (RuleCall)cOwnedImportsAssignment_0.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Assignment cOwnedPackagesAssignment_1_0 = (Assignment)cAlternatives_1.eContents().get(0);
		private final RuleCall cOwnedPackagesUnitPackageCSParserRuleCall_1_0_0 = (RuleCall)cOwnedPackagesAssignment_1_0.eContents().get(0);
		private final Assignment cOwnedTypesAssignment_1_1 = (Assignment)cAlternatives_1.eContents().get(1);
		private final RuleCall cOwnedTypesUnitTypeCSParserRuleCall_1_1_0 = (RuleCall)cOwnedTypesAssignment_1_1.eContents().get(0);
		
		//TopLevelCS:
		//	ownedImports+=ImportCS* (ownedPackages+=UnitPackageCS | ownedTypes+=UnitTypeCS)*;
		@Override public ParserRule getRule() { return rule; }

		//ownedImports+=ImportCS* (ownedPackages+=UnitPackageCS | ownedTypes+=UnitTypeCS)*
		public Group getGroup() { return cGroup; }

		//ownedImports+=ImportCS*
		public Assignment getOwnedImportsAssignment_0() { return cOwnedImportsAssignment_0; }

		//ImportCS
		public RuleCall getOwnedImportsImportCSParserRuleCall_0_0() { return cOwnedImportsImportCSParserRuleCall_0_0; }

		//(ownedPackages+=UnitPackageCS | ownedTypes+=UnitTypeCS)*
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//ownedPackages+=UnitPackageCS
		public Assignment getOwnedPackagesAssignment_1_0() { return cOwnedPackagesAssignment_1_0; }

		//UnitPackageCS
		public RuleCall getOwnedPackagesUnitPackageCSParserRuleCall_1_0_0() { return cOwnedPackagesUnitPackageCSParserRuleCall_1_0_0; }

		//ownedTypes+=UnitTypeCS
		public Assignment getOwnedTypesAssignment_1_1() { return cOwnedTypesAssignment_1_1; }

		//UnitTypeCS
		public RuleCall getOwnedTypesUnitTypeCSParserRuleCall_1_1_0() { return cOwnedTypesUnitTypeCSParserRuleCall_1_1_0; }
	}

	public class TransformationQualifierElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TransformationQualifier");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cBlackboxKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cAbstractKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cStaticKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		////enum ParamDirection : IN='in' | INOUT='inout' | OUT='out';
		// // FIXME use a CS element and unordered groups
		//
		//TransformationQualifier returns ecore::EString:
		//	"blackbox" | "abstract" | "static";
		@Override public ParserRule getRule() { return rule; }

		//"blackbox" | "abstract" | "static"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"blackbox"
		public Keyword getBlackboxKeyword_0() { return cBlackboxKeyword_0; }

		//"abstract"
		public Keyword getAbstractKeyword_1() { return cAbstractKeyword_1; }

		//"static"
		public Keyword getStaticKeyword_2() { return cStaticKeyword_2; }
	}

	public class LibraryQualifierElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LibraryQualifier");
		private final Keyword cBlackboxKeyword = (Keyword)rule.eContents().get(1);
		
		//LibraryQualifier returns ecore::EString:
		//	"blackbox";
		@Override public ParserRule getRule() { return rule; }

		//"blackbox"
		public Keyword getBlackboxKeyword() { return cBlackboxKeyword; }
	}

	public class FeatureQualifierElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FeatureQualifier");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cComposesKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cReferencesKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cReadonlyKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cDerivedKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cStaticKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		
		//FeatureQualifier returns ecore::EString:
		//	"composes" | "references" | "readonly" | "derived" | "static";
		@Override public ParserRule getRule() { return rule; }

		//"composes" | "references" | "readonly" | "derived" | "static"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"composes"
		public Keyword getComposesKeyword_0() { return cComposesKeyword_0; }

		//"references"
		public Keyword getReferencesKeyword_1() { return cReferencesKeyword_1; }

		//"readonly"
		public Keyword getReadonlyKeyword_2() { return cReadonlyKeyword_2; }

		//"derived"
		public Keyword getDerivedKeyword_3() { return cDerivedKeyword_3; }

		//"static"
		public Keyword getStaticKeyword_4() { return cStaticKeyword_4; }
	}

	public class OperationQualifierElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "OperationQualifier");
		private final Keyword cBlackboxKeyword = (Keyword)rule.eContents().get(1);
		
		//OperationQualifier returns ecore::EString:
		//	"blackbox";
		@Override public ParserRule getRule() { return rule; }

		//"blackbox"
		public Keyword getBlackboxKeyword() { return cBlackboxKeyword; }
	}

	public class PathName2CSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PathName2CS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cOwnedPathElements2Assignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cOwnedPathElements2PathElement2CSParserRuleCall_0_0 = (RuleCall)cOwnedPathElements2Assignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cColonColonKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cOwnedPathElements2Assignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOwnedPathElements2PathElement2CSParserRuleCall_1_1_0 = (RuleCall)cOwnedPathElements2Assignment_1_1.eContents().get(0);
		
		//// ****** OCL redifinitions ****** //
		// PathName2CS:
		//	ownedPathElements2+=PathElement2CS ("::" ownedPathElements2+=PathElement2CS)*;
		@Override public ParserRule getRule() { return rule; }

		//ownedPathElements2+=PathElement2CS ("::" ownedPathElements2+=PathElement2CS)*
		public Group getGroup() { return cGroup; }

		//ownedPathElements2+=PathElement2CS
		public Assignment getOwnedPathElements2Assignment_0() { return cOwnedPathElements2Assignment_0; }

		//PathElement2CS
		public RuleCall getOwnedPathElements2PathElement2CSParserRuleCall_0_0() { return cOwnedPathElements2PathElement2CSParserRuleCall_0_0; }

		//("::" ownedPathElements2+=PathElement2CS)*
		public Group getGroup_1() { return cGroup_1; }

		//"::"
		public Keyword getColonColonKeyword_1_0() { return cColonColonKeyword_1_0; }

		//ownedPathElements2+=PathElement2CS
		public Assignment getOwnedPathElements2Assignment_1_1() { return cOwnedPathElements2Assignment_1_1; }

		//PathElement2CS
		public RuleCall getOwnedPathElements2PathElement2CSParserRuleCall_1_1_0() { return cOwnedPathElements2PathElement2CSParserRuleCall_1_1_0; }
	}

	public class PathElement2CSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PathElement2CS");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameUnrestrictedNameParserRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//PathElement2CS:
		//	name=UnrestrictedName;
		@Override public ParserRule getRule() { return rule; }

		//name=UnrestrictedName
		public Assignment getNameAssignment() { return cNameAssignment; }

		//UnrestrictedName
		public RuleCall getNameUnrestrictedNameParserRuleCall_0() { return cNameUnrestrictedNameParserRuleCall_0; }
	}

	public class ImportCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ImportCS");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cImportKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Assignment cUnitAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cUnitUnitCSParserRuleCall_0_1_0 = (RuleCall)cUnitAssignment_0_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cFromKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cUnitAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cUnitUnitCSParserRuleCall_1_1_0 = (RuleCall)cUnitAssignment_1_1.eContents().get(0);
		private final Keyword cImportKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		private final Alternatives cAlternatives_1_3 = (Alternatives)cGroup_1.eContents().get(3);
		private final Group cGroup_1_3_0 = (Group)cAlternatives_1_3.eContents().get(0);
		private final Assignment cImportedUnitElementAssignment_1_3_0_0 = (Assignment)cGroup_1_3_0.eContents().get(0);
		private final RuleCall cImportedUnitElementIdentifierParserRuleCall_1_3_0_0_0 = (RuleCall)cImportedUnitElementAssignment_1_3_0_0.eContents().get(0);
		private final Group cGroup_1_3_0_1 = (Group)cGroup_1_3_0.eContents().get(1);
		private final Keyword cCommaKeyword_1_3_0_1_0 = (Keyword)cGroup_1_3_0_1.eContents().get(0);
		private final Assignment cImportedUnitElementAssignment_1_3_0_1_1 = (Assignment)cGroup_1_3_0_1.eContents().get(1);
		private final RuleCall cImportedUnitElementIdentifierParserRuleCall_1_3_0_1_1_0 = (RuleCall)cImportedUnitElementAssignment_1_3_0_1_1.eContents().get(0);
		private final Assignment cIsAllAssignment_1_3_1 = (Assignment)cAlternatives_1_3.eContents().get(1);
		private final Keyword cIsAllAsteriskKeyword_1_3_1_0 = (Keyword)cIsAllAssignment_1_3_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_1_4 = (Keyword)cGroup_1.eContents().get(4);
		
		//// ****** Imports ******
		// ImportCS returns QVToImportCS:
		//	"import" unit=UnitCS ";" | "from" unit=UnitCS "import" (importedUnitElement+=Identifier (","
		//	importedUnitElement+=Identifier)* | isAll?="*") ";";
		@Override public ParserRule getRule() { return rule; }

		//"import" unit=UnitCS ";" | "from" unit=UnitCS "import" (importedUnitElement+=Identifier (","
		//importedUnitElement+=Identifier)* | isAll?="*") ";"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"import" unit=UnitCS ";"
		public Group getGroup_0() { return cGroup_0; }

		//"import"
		public Keyword getImportKeyword_0_0() { return cImportKeyword_0_0; }

		//unit=UnitCS
		public Assignment getUnitAssignment_0_1() { return cUnitAssignment_0_1; }

		//UnitCS
		public RuleCall getUnitUnitCSParserRuleCall_0_1_0() { return cUnitUnitCSParserRuleCall_0_1_0; }

		//";"
		public Keyword getSemicolonKeyword_0_2() { return cSemicolonKeyword_0_2; }

		//"from" unit=UnitCS "import" (importedUnitElement+=Identifier ("," importedUnitElement+=Identifier)* | isAll?="*") ";"
		public Group getGroup_1() { return cGroup_1; }

		//"from"
		public Keyword getFromKeyword_1_0() { return cFromKeyword_1_0; }

		//unit=UnitCS
		public Assignment getUnitAssignment_1_1() { return cUnitAssignment_1_1; }

		//UnitCS
		public RuleCall getUnitUnitCSParserRuleCall_1_1_0() { return cUnitUnitCSParserRuleCall_1_1_0; }

		//"import"
		public Keyword getImportKeyword_1_2() { return cImportKeyword_1_2; }

		//importedUnitElement+=Identifier ("," importedUnitElement+=Identifier)* | isAll?="*"
		public Alternatives getAlternatives_1_3() { return cAlternatives_1_3; }

		//importedUnitElement+=Identifier ("," importedUnitElement+=Identifier)*
		public Group getGroup_1_3_0() { return cGroup_1_3_0; }

		//importedUnitElement+=Identifier
		public Assignment getImportedUnitElementAssignment_1_3_0_0() { return cImportedUnitElementAssignment_1_3_0_0; }

		//Identifier
		public RuleCall getImportedUnitElementIdentifierParserRuleCall_1_3_0_0_0() { return cImportedUnitElementIdentifierParserRuleCall_1_3_0_0_0; }

		//("," importedUnitElement+=Identifier)*
		public Group getGroup_1_3_0_1() { return cGroup_1_3_0_1; }

		//","
		public Keyword getCommaKeyword_1_3_0_1_0() { return cCommaKeyword_1_3_0_1_0; }

		//importedUnitElement+=Identifier
		public Assignment getImportedUnitElementAssignment_1_3_0_1_1() { return cImportedUnitElementAssignment_1_3_0_1_1; }

		//Identifier
		public RuleCall getImportedUnitElementIdentifierParserRuleCall_1_3_0_1_1_0() { return cImportedUnitElementIdentifierParserRuleCall_1_3_0_1_1_0; }

		//isAll?="*"
		public Assignment getIsAllAssignment_1_3_1() { return cIsAllAssignment_1_3_1; }

		//"*"
		public Keyword getIsAllAsteriskKeyword_1_3_1_0() { return cIsAllAsteriskKeyword_1_3_1_0; }

		//";"
		public Keyword getSemicolonKeyword_1_4() { return cSemicolonKeyword_1_4; }
	}

	public class UnitCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UnitCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cSegmentAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cSegmentIdentifierParserRuleCall_0_0 = (RuleCall)cSegmentAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cFullStopKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cSegmentAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cSegmentIdentifierParserRuleCall_1_1_0 = (RuleCall)cSegmentAssignment_1_1.eContents().get(0);
		
		//UnitCS:
		//	segment+=Identifier ("." segment+=Identifier)*;
		@Override public ParserRule getRule() { return rule; }

		//segment+=Identifier ("." segment+=Identifier)*
		public Group getGroup() { return cGroup; }

		//segment+=Identifier
		public Assignment getSegmentAssignment_0() { return cSegmentAssignment_0; }

		//Identifier
		public RuleCall getSegmentIdentifierParserRuleCall_0_0() { return cSegmentIdentifierParserRuleCall_0_0; }

		//("." segment+=Identifier)*
		public Group getGroup_1() { return cGroup_1; }

		//"."
		public Keyword getFullStopKeyword_1_0() { return cFullStopKeyword_1_0; }

		//segment+=Identifier
		public Assignment getSegmentAssignment_1_1() { return cSegmentAssignment_1_1; }

		//Identifier
		public RuleCall getSegmentIdentifierParserRuleCall_1_1_0() { return cSegmentIdentifierParserRuleCall_1_1_0; }
	}

	public class UnitPackageCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UnitPackageCS");
		private final RuleCall cMetamodelCSParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//// ****** definitions in a compilation unit *******
		// UnitPackageCS returns base::PackageCS:
		//	MetamodelCS;
		@Override public ParserRule getRule() { return rule; }

		//MetamodelCS
		public RuleCall getMetamodelCSParserRuleCall() { return cMetamodelCSParserRuleCall; }
	}

	public class UnitTypeCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UnitTypeCS");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cModelTypeCSParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cTransformationCSParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cLibraryCSParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//UnitTypeCS returns base::TypeCS:
		//	ModelTypeCS | TransformationCS | LibraryCS;
		@Override public ParserRule getRule() { return rule; }

		//ModelTypeCS | TransformationCS | LibraryCS
		public Alternatives getAlternatives() { return cAlternatives; }

		//ModelTypeCS
		public RuleCall getModelTypeCSParserRuleCall_0() { return cModelTypeCSParserRuleCall_0; }

		//TransformationCS
		public RuleCall getTransformationCSParserRuleCall_1() { return cTransformationCSParserRuleCall_1; }

		//LibraryCS
		public RuleCall getLibraryCSParserRuleCall_2() { return cLibraryCSParserRuleCall_2; }
	}

	public class ParameterCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ParameterCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameUnrestrictedNameParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cColonKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cOwnedTypeAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOwnedTypeTypedMultiplicityRef2CSParserRuleCall_1_1_0 = (RuleCall)cOwnedTypeAssignment_1_1.eContents().get(0);
		
		//// ****** General rules ******
		//
		////CompleteSignatureCS: SimpleSignatureCS (':' (param+=ParameterCS (',' param+=ParameterCS)*))?;
		// //
		//
		////SimpleSignatureCS: {SimpleSignatureCS} 
		//
		////	'(' (parameter+=ParameterDeclarationCS (',' parameter+=ParameterDeclarationCS)*)? ')'
		// //;
		// ParameterCS returns
		//base::ParameterCS:
		//	name=UnrestrictedName (":" ownedType=TypedMultiplicityRef2CS)?;
		@Override public ParserRule getRule() { return rule; }

		//name=UnrestrictedName (":" ownedType=TypedMultiplicityRef2CS)?
		public Group getGroup() { return cGroup; }

		//name=UnrestrictedName
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//UnrestrictedName
		public RuleCall getNameUnrestrictedNameParserRuleCall_0_0() { return cNameUnrestrictedNameParserRuleCall_0_0; }

		//(":" ownedType=TypedMultiplicityRef2CS)?
		public Group getGroup_1() { return cGroup_1; }

		//":"
		public Keyword getColonKeyword_1_0() { return cColonKeyword_1_0; }

		//ownedType=TypedMultiplicityRef2CS
		public Assignment getOwnedTypeAssignment_1_1() { return cOwnedTypeAssignment_1_1; }

		//TypedMultiplicityRef2CS
		public RuleCall getOwnedTypeTypedMultiplicityRef2CSParserRuleCall_1_1_0() { return cOwnedTypeTypedMultiplicityRef2CSParserRuleCall_1_1_0; }
	}

	public class ParameterDeclarationCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ParameterDeclarationCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cDirectionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cDirectionDirectionKindCSEnumRuleCall_0_0 = (RuleCall)cDirectionAssignment_0.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameUnrestrictedNameParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cColonKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cOwnedTypeAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cOwnedTypeTypedMultiplicityRef2CSParserRuleCall_2_1_0 = (RuleCall)cOwnedTypeAssignment_2_1.eContents().get(0);
		private final Assignment cInitPartAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cInitPartInitPartCSParserRuleCall_3_0 = (RuleCall)cInitPartAssignment_3.eContents().get(0);
		
		//ParameterDeclarationCS:
		//	direction=DirectionKindCS? name= // FIXME Spec grammar says that you can have just a typeSpec
		// UnrestrictedName
		//	// TODO (':' ownedType=TypedMultiplicityRefCS)?
		// (":" ownedType=TypedMultiplicityRef2CS)? initPart=InitPartCS?;
		@Override public ParserRule getRule() { return rule; }

		//direction=DirectionKindCS? name= // FIXME Spec grammar says that you can have just a typeSpec
		// UnrestrictedName
		//// TODO (':' ownedType=TypedMultiplicityRefCS)?
		// (":" ownedType=TypedMultiplicityRef2CS)? initPart=InitPartCS?
		public Group getGroup() { return cGroup; }

		//direction=DirectionKindCS?
		public Assignment getDirectionAssignment_0() { return cDirectionAssignment_0; }

		//DirectionKindCS
		public RuleCall getDirectionDirectionKindCSEnumRuleCall_0_0() { return cDirectionDirectionKindCSEnumRuleCall_0_0; }

		//name= // FIXME Spec grammar says that you can have just a typeSpec
		// UnrestrictedName
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//// FIXME Spec grammar says that you can have just a typeSpec
		// UnrestrictedName
		public RuleCall getNameUnrestrictedNameParserRuleCall_1_0() { return cNameUnrestrictedNameParserRuleCall_1_0; }

		//(":" ownedType=TypedMultiplicityRef2CS)?
		public Group getGroup_2() { return cGroup_2; }

		//":"
		public Keyword getColonKeyword_2_0() { return cColonKeyword_2_0; }

		//ownedType=TypedMultiplicityRef2CS
		public Assignment getOwnedTypeAssignment_2_1() { return cOwnedTypeAssignment_2_1; }

		//TypedMultiplicityRef2CS
		public RuleCall getOwnedTypeTypedMultiplicityRef2CSParserRuleCall_2_1_0() { return cOwnedTypeTypedMultiplicityRef2CSParserRuleCall_2_1_0; }

		//initPart=InitPartCS?
		public Assignment getInitPartAssignment_3() { return cInitPartAssignment_3; }

		//InitPartCS
		public RuleCall getInitPartInitPartCSParserRuleCall_3_0() { return cInitPartInitPartCSParserRuleCall_3_0; }
	}

	public class InitPartCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "InitPartCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cInitOpAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cInitOpInitOpEnumRuleCall_0_0 = (RuleCall)cInitOpAssignment_0.eContents().get(0);
		private final Assignment cExpressionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExpressionExpCSParserRuleCall_1_0 = (RuleCall)cExpressionAssignment_1.eContents().get(0);
		
		//// TODO also remove the corresponding CS metamodel element
		// //OperationSimpleSignatureCS : {OperationSimpleSignatureCS}
		//
		////	'(' (parameter+= OperationParameterDeclarationCS (',' parameter+= OperationParameterDeclarationCS)*)? ')'
		// //;
		//
		////OperationParameterDeclarationCS :
		// //	direction=DirectionKindCS? 
		//
		////	name=UnrestrictedName // FIXME Spec grammar says that you can have just a typeSpec  
		//
		////	(':' ownedType=TypeSpecCS)?
		// //	initPart=InitPartCS?
		// //;
		// InitPartCS:
		//	initOp=InitOp expression=ExpCS;
		@Override public ParserRule getRule() { return rule; }

		//initOp=InitOp expression=ExpCS
		public Group getGroup() { return cGroup; }

		//initOp=InitOp
		public Assignment getInitOpAssignment_0() { return cInitOpAssignment_0; }

		//InitOp
		public RuleCall getInitOpInitOpEnumRuleCall_0_0() { return cInitOpInitOpEnumRuleCall_0_0; }

		//expression=ExpCS
		public Assignment getExpressionAssignment_1() { return cExpressionAssignment_1; }

		//ExpCS
		public RuleCall getExpressionExpCSParserRuleCall_1_0() { return cExpressionExpCSParserRuleCall_1_0; }
	}

	public class TypeSpecCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TypeSpecCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cOwnedTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cOwnedTypeTypedRefCSParserRuleCall_0_0 = (RuleCall)cOwnedTypeAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommercialAtKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cExtentLocationAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cExtentLocationUnrestrictedNameParserRuleCall_1_1_0 = (RuleCall)cExtentLocationAssignment_1_1.eContents().get(0);
		
		//TypeSpecCS:
		//	ownedType=TypedRefCS ("@" extentLocation=UnrestrictedName)?;
		@Override public ParserRule getRule() { return rule; }

		//ownedType=TypedRefCS ("@" extentLocation=UnrestrictedName)?
		public Group getGroup() { return cGroup; }

		//ownedType=TypedRefCS
		public Assignment getOwnedTypeAssignment_0() { return cOwnedTypeAssignment_0; }

		//TypedRefCS
		public RuleCall getOwnedTypeTypedRefCSParserRuleCall_0_0() { return cOwnedTypeTypedRefCSParserRuleCall_0_0; }

		//("@" extentLocation=UnrestrictedName)?
		public Group getGroup_1() { return cGroup_1; }

		//"@"
		public Keyword getCommercialAtKeyword_1_0() { return cCommercialAtKeyword_1_0; }

		//extentLocation=UnrestrictedName
		public Assignment getExtentLocationAssignment_1_1() { return cExtentLocationAssignment_1_1; }

		//UnrestrictedName
		public RuleCall getExtentLocationUnrestrictedNameParserRuleCall_1_1_0() { return cExtentLocationUnrestrictedNameParserRuleCall_1_1_0; }
	}

	public class MetamodelCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MetamodelCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cMetamodelKindAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cMetamodelKindMetamodelKindEnumRuleCall_0_0 = (RuleCall)cMetamodelKindAssignment_0.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameUnrestrictedNameParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Alternatives cAlternatives_3 = (Alternatives)cGroup.eContents().get(3);
		private final Assignment cOwnedClassesAssignment_3_0 = (Assignment)cAlternatives_3.eContents().get(0);
		private final RuleCall cOwnedClassesClassCSParserRuleCall_3_0_0 = (RuleCall)cOwnedClassesAssignment_3_0.eContents().get(0);
		private final Assignment cOwnedClassesAssignment_3_1 = (Assignment)cAlternatives_3.eContents().get(1);
		private final RuleCall cOwnedClassesEnumerationCSParserRuleCall_3_1_0 = (RuleCall)cOwnedClassesAssignment_3_1.eContents().get(0);
		private final Assignment cOwnedAnnotationsAssignment_3_2 = (Assignment)cAlternatives_3.eContents().get(2);
		private final RuleCall cOwnedAnnotationsTagCSParserRuleCall_3_2_0 = (RuleCall)cOwnedAnnotationsAssignment_3_2.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Keyword cSemicolonKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//// General rules END
		// // ****** Syntax for defining explicitly metamodel contents ******
		//
		//// MetamodelKind provides extra semantic, we need to retain the kind 
		// MetamodelCS:
		//	metamodelKind=MetamodelKind name=UnrestrictedName "{" (ownedClasses+=ClassCS
		//	// FIXME QVTo grammar distincts classifier from enumeration
		// | ownedClasses+=EnumerationCS |
		//	ownedAnnotations+=TagCS)* "}" ";"?;
		@Override public ParserRule getRule() { return rule; }

		//metamodelKind=MetamodelKind name=UnrestrictedName "{" (ownedClasses+=ClassCS
		//// FIXME QVTo grammar distincts classifier from enumeration
		// | ownedClasses+=EnumerationCS | ownedAnnotations+=TagCS)*
		//"}" ";"?
		public Group getGroup() { return cGroup; }

		//metamodelKind=MetamodelKind
		public Assignment getMetamodelKindAssignment_0() { return cMetamodelKindAssignment_0; }

		//MetamodelKind
		public RuleCall getMetamodelKindMetamodelKindEnumRuleCall_0_0() { return cMetamodelKindMetamodelKindEnumRuleCall_0_0; }

		//name=UnrestrictedName
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//UnrestrictedName
		public RuleCall getNameUnrestrictedNameParserRuleCall_1_0() { return cNameUnrestrictedNameParserRuleCall_1_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_2() { return cLeftCurlyBracketKeyword_2; }

		//(ownedClasses+=ClassCS // FIXME QVTo grammar distincts classifier from enumeration
		// | ownedClasses+=EnumerationCS |
		//ownedAnnotations+=TagCS)*
		public Alternatives getAlternatives_3() { return cAlternatives_3; }

		//ownedClasses+=ClassCS
		public Assignment getOwnedClassesAssignment_3_0() { return cOwnedClassesAssignment_3_0; }

		//ClassCS
		public RuleCall getOwnedClassesClassCSParserRuleCall_3_0_0() { return cOwnedClassesClassCSParserRuleCall_3_0_0; }

		//ownedClasses+=EnumerationCS
		public Assignment getOwnedClassesAssignment_3_1() { return cOwnedClassesAssignment_3_1; }

		//EnumerationCS
		public RuleCall getOwnedClassesEnumerationCSParserRuleCall_3_1_0() { return cOwnedClassesEnumerationCSParserRuleCall_3_1_0; }

		//ownedAnnotations+=TagCS
		public Assignment getOwnedAnnotationsAssignment_3_2() { return cOwnedAnnotationsAssignment_3_2; }

		//TagCS
		public RuleCall getOwnedAnnotationsTagCSParserRuleCall_3_2_0() { return cOwnedAnnotationsTagCSParserRuleCall_3_2_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }

		//";"?
		public Keyword getSemicolonKeyword_5() { return cSemicolonKeyword_5; }
	}

	public class ClassCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ClassCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final RuleCall cDataTypeCSParserRuleCall_0_0 = (RuleCall)cAlternatives_0.eContents().get(0);
		private final RuleCall cExceptionCSParserRuleCall_0_1 = (RuleCall)cAlternatives_0.eContents().get(1);
		private final RuleCall cQVToClassCSParserRuleCall_0_2 = (RuleCall)cAlternatives_0.eContents().get(2);
		private final Keyword cSemicolonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//ClassCS returns base::ClassCS:
		//	(DataTypeCS | ExceptionCS | QVToClassCS) ";"?;
		@Override public ParserRule getRule() { return rule; }

		//(DataTypeCS | ExceptionCS | QVToClassCS) ";"?
		public Group getGroup() { return cGroup; }

		//DataTypeCS | ExceptionCS | QVToClassCS
		public Alternatives getAlternatives_0() { return cAlternatives_0; }

		//DataTypeCS
		public RuleCall getDataTypeCSParserRuleCall_0_0() { return cDataTypeCSParserRuleCall_0_0; }

		//ExceptionCS
		public RuleCall getExceptionCSParserRuleCall_0_1() { return cExceptionCSParserRuleCall_0_1; }

		//QVToClassCS
		public RuleCall getQVToClassCSParserRuleCall_0_2() { return cQVToClassCSParserRuleCall_0_2; }

		//";"?
		public Keyword getSemicolonKeyword_1() { return cSemicolonKeyword_1; }
	}

	public class DataTypeCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DataTypeCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Keyword cDatatypeKeyword_0_0 = (Keyword)cAlternatives_0.eContents().get(0);
		private final Group cGroup_0_1 = (Group)cAlternatives_0.eContents().get(1);
		private final Action cPrimitiveTypeCSAction_0_1_0 = (Action)cGroup_0_1.eContents().get(0);
		private final Keyword cPrimitiveKeyword_0_1_1 = (Keyword)cGroup_0_1.eContents().get(1);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameUnrestrictedNameParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		
		//DataTypeCS returns base::DataTypeCS:
		//	("datatype" | {PrimitiveTypeCS} "primitive") name=UnrestrictedName;
		@Override public ParserRule getRule() { return rule; }

		//("datatype" | {PrimitiveTypeCS} "primitive") name=UnrestrictedName
		public Group getGroup() { return cGroup; }

		//"datatype" | {PrimitiveTypeCS} "primitive"
		public Alternatives getAlternatives_0() { return cAlternatives_0; }

		//"datatype"
		public Keyword getDatatypeKeyword_0_0() { return cDatatypeKeyword_0_0; }

		//{PrimitiveTypeCS} "primitive"
		public Group getGroup_0_1() { return cGroup_0_1; }

		//{PrimitiveTypeCS}
		public Action getPrimitiveTypeCSAction_0_1_0() { return cPrimitiveTypeCSAction_0_1_0; }

		//"primitive"
		public Keyword getPrimitiveKeyword_0_1_1() { return cPrimitiveKeyword_0_1_1; }

		//name=UnrestrictedName
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//UnrestrictedName
		public RuleCall getNameUnrestrictedNameParserRuleCall_1_0() { return cNameUnrestrictedNameParserRuleCall_1_0; }
	}

	public class ExceptionCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ExceptionCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cExceptionKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameUnrestrictedNameParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cExtendsKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Assignment cOwnedSuperTypesAssignment_2_1_0 = (Assignment)cGroup_2_1.eContents().get(0);
		private final RuleCall cOwnedSuperTypesTypedRefCSParserRuleCall_2_1_0_0 = (RuleCall)cOwnedSuperTypesAssignment_2_1_0.eContents().get(0);
		private final Group cGroup_2_1_1 = (Group)cGroup_2_1.eContents().get(1);
		private final Keyword cCommaKeyword_2_1_1_0 = (Keyword)cGroup_2_1_1.eContents().get(0);
		private final Assignment cOwnedSuperTypesAssignment_2_1_1_1 = (Assignment)cGroup_2_1_1.eContents().get(1);
		private final RuleCall cOwnedSuperTypesTypedRefCSParserRuleCall_2_1_1_1_0 = (RuleCall)cOwnedSuperTypesAssignment_2_1_1_1.eContents().get(0);
		
		//// FIXME so far, exception is another class
		// ExceptionCS returns base::StructuredClassCS:
		//	"exception" name=UnrestrictedName ("extends" (ownedSuperTypes+=TypedRefCS ("," ownedSuperTypes+=TypedRefCS)*))?;
		@Override public ParserRule getRule() { return rule; }

		//"exception" name=UnrestrictedName ("extends" (ownedSuperTypes+=TypedRefCS ("," ownedSuperTypes+=TypedRefCS)*))?
		public Group getGroup() { return cGroup; }

		//"exception"
		public Keyword getExceptionKeyword_0() { return cExceptionKeyword_0; }

		//name=UnrestrictedName
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//UnrestrictedName
		public RuleCall getNameUnrestrictedNameParserRuleCall_1_0() { return cNameUnrestrictedNameParserRuleCall_1_0; }

		//("extends" (ownedSuperTypes+=TypedRefCS ("," ownedSuperTypes+=TypedRefCS)*))?
		public Group getGroup_2() { return cGroup_2; }

		//"extends"
		public Keyword getExtendsKeyword_2_0() { return cExtendsKeyword_2_0; }

		//ownedSuperTypes+=TypedRefCS ("," ownedSuperTypes+=TypedRefCS)*
		public Group getGroup_2_1() { return cGroup_2_1; }

		//ownedSuperTypes+=TypedRefCS
		public Assignment getOwnedSuperTypesAssignment_2_1_0() { return cOwnedSuperTypesAssignment_2_1_0; }

		//TypedRefCS
		public RuleCall getOwnedSuperTypesTypedRefCSParserRuleCall_2_1_0_0() { return cOwnedSuperTypesTypedRefCSParserRuleCall_2_1_0_0; }

		//("," ownedSuperTypes+=TypedRefCS)*
		public Group getGroup_2_1_1() { return cGroup_2_1_1; }

		//","
		public Keyword getCommaKeyword_2_1_1_0() { return cCommaKeyword_2_1_1_0; }

		//ownedSuperTypes+=TypedRefCS
		public Assignment getOwnedSuperTypesAssignment_2_1_1_1() { return cOwnedSuperTypesAssignment_2_1_1_1; }

		//TypedRefCS
		public RuleCall getOwnedSuperTypesTypedRefCSParserRuleCall_2_1_1_1_0() { return cOwnedSuperTypesTypedRefCSParserRuleCall_2_1_1_1_0; }
	}

	public class QVToClassCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "QVToClassCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cIntermediateAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cIntermediateIntermediateKeyword_0_0 = (Keyword)cIntermediateAssignment_0.eContents().get(0);
		private final Keyword cClassKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameUnrestrictedNameParserRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cExtendsKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Group cGroup_3_1 = (Group)cGroup_3.eContents().get(1);
		private final Assignment cOwnedSuperTypesAssignment_3_1_0 = (Assignment)cGroup_3_1.eContents().get(0);
		private final RuleCall cOwnedSuperTypesTypedRefCSParserRuleCall_3_1_0_0 = (RuleCall)cOwnedSuperTypesAssignment_3_1_0.eContents().get(0);
		private final Group cGroup_3_1_1 = (Group)cGroup_3_1.eContents().get(1);
		private final Keyword cCommaKeyword_3_1_1_0 = (Keyword)cGroup_3_1_1.eContents().get(0);
		private final Assignment cOwnedSuperTypesAssignment_3_1_1_1 = (Assignment)cGroup_3_1_1.eContents().get(1);
		private final RuleCall cOwnedSuperTypesTypedRefCSParserRuleCall_3_1_1_1_0 = (RuleCall)cOwnedSuperTypesAssignment_3_1_1_1.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cLeftCurlyBracketKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Group cGroup_4_1 = (Group)cGroup_4.eContents().get(1);
		private final Alternatives cAlternatives_4_1_0 = (Alternatives)cGroup_4_1.eContents().get(0);
		private final Assignment cOwnedPropertiesAssignment_4_1_0_0 = (Assignment)cAlternatives_4_1_0.eContents().get(0);
		private final RuleCall cOwnedPropertiesClassifierPropertyCSParserRuleCall_4_1_0_0_0 = (RuleCall)cOwnedPropertiesAssignment_4_1_0_0.eContents().get(0);
		private final Assignment cOwnedOperationsAssignment_4_1_0_1 = (Assignment)cAlternatives_4_1_0.eContents().get(1);
		private final RuleCall cOwnedOperationsClassifierOperationCSParserRuleCall_4_1_0_1_0 = (RuleCall)cOwnedOperationsAssignment_4_1_0_1.eContents().get(0);
		private final Assignment cOwnedAnnotationsAssignment_4_1_0_2 = (Assignment)cAlternatives_4_1_0.eContents().get(2);
		private final RuleCall cOwnedAnnotationsTagCSParserRuleCall_4_1_0_2_0 = (RuleCall)cOwnedAnnotationsAssignment_4_1_0_2.eContents().get(0);
		private final Keyword cSemicolonKeyword_4_1_1 = (Keyword)cGroup_4_1.eContents().get(1);
		private final Keyword cRightCurlyBracketKeyword_4_2 = (Keyword)cGroup_4.eContents().get(2);
		
		//QVToClassCS:
		//	intermediate?="intermediate"? // qualifier += Qualifier*
		// "class" name=UnrestrictedName ("extends"
		//	(ownedSuperTypes+=TypedRefCS ("," ownedSuperTypes+=TypedRefCS)*))? ("{" ((ownedProperties+=ClassifierPropertyCS |
		//	ownedOperations+=ClassifierOperationCS | ownedAnnotations+=TagCS) ";")+ "}")?;
		@Override public ParserRule getRule() { return rule; }

		//intermediate?="intermediate"? // qualifier += Qualifier*
		// "class" name=UnrestrictedName ("extends"
		//(ownedSuperTypes+=TypedRefCS ("," ownedSuperTypes+=TypedRefCS)*))? ("{" ((ownedProperties+=ClassifierPropertyCS |
		//ownedOperations+=ClassifierOperationCS | ownedAnnotations+=TagCS) ";")+ "}")?
		public Group getGroup() { return cGroup; }

		//intermediate?="intermediate"?
		public Assignment getIntermediateAssignment_0() { return cIntermediateAssignment_0; }

		//"intermediate"
		public Keyword getIntermediateIntermediateKeyword_0_0() { return cIntermediateIntermediateKeyword_0_0; }

		//// qualifier += Qualifier*
		// "class"
		public Keyword getClassKeyword_1() { return cClassKeyword_1; }

		//name=UnrestrictedName
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }

		//UnrestrictedName
		public RuleCall getNameUnrestrictedNameParserRuleCall_2_0() { return cNameUnrestrictedNameParserRuleCall_2_0; }

		//("extends" (ownedSuperTypes+=TypedRefCS ("," ownedSuperTypes+=TypedRefCS)*))?
		public Group getGroup_3() { return cGroup_3; }

		//"extends"
		public Keyword getExtendsKeyword_3_0() { return cExtendsKeyword_3_0; }

		//ownedSuperTypes+=TypedRefCS ("," ownedSuperTypes+=TypedRefCS)*
		public Group getGroup_3_1() { return cGroup_3_1; }

		//ownedSuperTypes+=TypedRefCS
		public Assignment getOwnedSuperTypesAssignment_3_1_0() { return cOwnedSuperTypesAssignment_3_1_0; }

		//TypedRefCS
		public RuleCall getOwnedSuperTypesTypedRefCSParserRuleCall_3_1_0_0() { return cOwnedSuperTypesTypedRefCSParserRuleCall_3_1_0_0; }

		//("," ownedSuperTypes+=TypedRefCS)*
		public Group getGroup_3_1_1() { return cGroup_3_1_1; }

		//","
		public Keyword getCommaKeyword_3_1_1_0() { return cCommaKeyword_3_1_1_0; }

		//ownedSuperTypes+=TypedRefCS
		public Assignment getOwnedSuperTypesAssignment_3_1_1_1() { return cOwnedSuperTypesAssignment_3_1_1_1; }

		//TypedRefCS
		public RuleCall getOwnedSuperTypesTypedRefCSParserRuleCall_3_1_1_1_0() { return cOwnedSuperTypesTypedRefCSParserRuleCall_3_1_1_1_0; }

		//("{" ((ownedProperties+=ClassifierPropertyCS | ownedOperations+=ClassifierOperationCS | ownedAnnotations+=TagCS) ";")+
		//"}")?
		public Group getGroup_4() { return cGroup_4; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_4_0() { return cLeftCurlyBracketKeyword_4_0; }

		//((ownedProperties+=ClassifierPropertyCS | ownedOperations+=ClassifierOperationCS | ownedAnnotations+=TagCS) ";")+
		public Group getGroup_4_1() { return cGroup_4_1; }

		//ownedProperties+=ClassifierPropertyCS | ownedOperations+=ClassifierOperationCS | ownedAnnotations+=TagCS
		public Alternatives getAlternatives_4_1_0() { return cAlternatives_4_1_0; }

		//ownedProperties+=ClassifierPropertyCS
		public Assignment getOwnedPropertiesAssignment_4_1_0_0() { return cOwnedPropertiesAssignment_4_1_0_0; }

		//ClassifierPropertyCS
		public RuleCall getOwnedPropertiesClassifierPropertyCSParserRuleCall_4_1_0_0_0() { return cOwnedPropertiesClassifierPropertyCSParserRuleCall_4_1_0_0_0; }

		//ownedOperations+=ClassifierOperationCS
		public Assignment getOwnedOperationsAssignment_4_1_0_1() { return cOwnedOperationsAssignment_4_1_0_1; }

		//ClassifierOperationCS
		public RuleCall getOwnedOperationsClassifierOperationCSParserRuleCall_4_1_0_1_0() { return cOwnedOperationsClassifierOperationCSParserRuleCall_4_1_0_1_0; }

		//ownedAnnotations+=TagCS
		public Assignment getOwnedAnnotationsAssignment_4_1_0_2() { return cOwnedAnnotationsAssignment_4_1_0_2; }

		//TagCS
		public RuleCall getOwnedAnnotationsTagCSParserRuleCall_4_1_0_2_0() { return cOwnedAnnotationsTagCSParserRuleCall_4_1_0_2_0; }

		//";"
		public Keyword getSemicolonKeyword_4_1_1() { return cSemicolonKeyword_4_1_1; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_4_2() { return cRightCurlyBracketKeyword_4_2; }
	}

	public class TypedMultiplicityRef2CSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TypedMultiplicityRef2CS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cTypedRef2CSParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Assignment cOwnedMultiplicityAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cOwnedMultiplicityMultiplicityCSParserRuleCall_1_0 = (RuleCall)cOwnedMultiplicityAssignment_1.eContents().get(0);
		
		//TypedMultiplicityRef2CS returns base::TypedRefCS:
		//	TypedRef2CS ownedMultiplicity=MultiplicityCS?;
		@Override public ParserRule getRule() { return rule; }

		//TypedRef2CS ownedMultiplicity=MultiplicityCS?
		public Group getGroup() { return cGroup; }

		//TypedRef2CS
		public RuleCall getTypedRef2CSParserRuleCall_0() { return cTypedRef2CSParserRuleCall_0; }

		//ownedMultiplicity=MultiplicityCS?
		public Assignment getOwnedMultiplicityAssignment_1() { return cOwnedMultiplicityAssignment_1; }

		//MultiplicityCS
		public RuleCall getOwnedMultiplicityMultiplicityCSParserRuleCall_1_0() { return cOwnedMultiplicityMultiplicityCSParserRuleCall_1_0; }
	}

	public class TypeRef2CSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TypeRef2CS");
		private final RuleCall cTypedRef2CSParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//// FIXME deviation from OCLInEcore. No templates parameter, yet
		// TypeRef2CS returns base::TypeRefCS:
		//// | WildcardTypeRefCS
		// TypedRef2CS;
		@Override public ParserRule getRule() { return rule; }

		//// | WildcardTypeRefCS
		// TypedRef2CS
		public RuleCall getTypedRef2CSParserRuleCall() { return cTypedRef2CSParserRuleCall; }
	}

	public class TypedRef2CSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TypedRef2CS");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cTypeLiteralCSParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cTypedTypeRef2CSParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//TypedRef2CS returns base::TypedRefCS:
		//	TypeLiteralCS | TypedTypeRef2CS;
		@Override public ParserRule getRule() { return rule; }

		//TypeLiteralCS | TypedTypeRef2CS
		public Alternatives getAlternatives() { return cAlternatives; }

		//TypeLiteralCS
		public RuleCall getTypeLiteralCSParserRuleCall_0() { return cTypeLiteralCSParserRuleCall_0; }

		//TypedTypeRef2CS
		public RuleCall getTypedTypeRef2CSParserRuleCall_1() { return cTypedTypeRef2CSParserRuleCall_1; }
	}

	public class TypedTypeRef2CSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TypedTypeRef2CS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cOwnedPathNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cOwnedPathNamePathName2CSParserRuleCall_0_0 = (RuleCall)cOwnedPathNameAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cOwnedBindingAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOwnedBindingTemplateBindingCSParserRuleCall_1_1_0 = (RuleCall)cOwnedBindingAssignment_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		
		//TypedTypeRef2CS:
		//	ownedPathName=PathName2CS ("(" ownedBinding=TemplateBindingCS ")")?;
		@Override public ParserRule getRule() { return rule; }

		//ownedPathName=PathName2CS ("(" ownedBinding=TemplateBindingCS ")")?
		public Group getGroup() { return cGroup; }

		//ownedPathName=PathName2CS
		public Assignment getOwnedPathNameAssignment_0() { return cOwnedPathNameAssignment_0; }

		//PathName2CS
		public RuleCall getOwnedPathNamePathName2CSParserRuleCall_0_0() { return cOwnedPathNamePathName2CSParserRuleCall_0_0; }

		//("(" ownedBinding=TemplateBindingCS ")")?
		public Group getGroup_1() { return cGroup_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_1_0() { return cLeftParenthesisKeyword_1_0; }

		//ownedBinding=TemplateBindingCS
		public Assignment getOwnedBindingAssignment_1_1() { return cOwnedBindingAssignment_1_1; }

		//TemplateBindingCS
		public RuleCall getOwnedBindingTemplateBindingCSParserRuleCall_1_1_0() { return cOwnedBindingTemplateBindingCSParserRuleCall_1_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_1_2() { return cRightParenthesisKeyword_1_2; }
	}

	public class ClassifierPropertyCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ClassifierPropertyCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cStereotypesAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cStereotypesStereotypeQualifierCSParserRuleCall_0_0 = (RuleCall)cStereotypesAssignment_0.eContents().get(0);
		private final Assignment cQualifiersAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cQualifiersFeatureQualifierParserRuleCall_1_0 = (RuleCall)cQualifiersAssignment_1.eContents().get(0);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameUnrestrictedNameParserRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Keyword cColonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cOwnedTypeAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cOwnedTypeTypedMultiplicityRef2CSParserRuleCall_4_0 = (RuleCall)cOwnedTypeAssignment_4.eContents().get(0);
		private final Assignment cDefaultAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cDefaultSINGLE_QUOTED_STRINGTerminalRuleCall_5_0 = (RuleCall)cDefaultAssignment_5.eContents().get(0);
		private final Group cGroup_6 = (Group)cGroup.eContents().get(6);
		private final Keyword cOppositesKeyword_6_0 = (Keyword)cGroup_6.eContents().get(0);
		private final Keyword cTildeKeyword_6_1 = (Keyword)cGroup_6.eContents().get(1);
		private final Assignment cOppositeAssignment_6_2 = (Assignment)cGroup_6.eContents().get(2);
		private final RuleCall cOppositeIdentifierParserRuleCall_6_2_0 = (RuleCall)cOppositeAssignment_6_2.eContents().get(0);
		
		//ClassifierPropertyCS:
		//	stereotypes=StereotypeQualifierCS? qualifiers+=FeatureQualifier* name=UnrestrictedName ":"
		//	ownedType=TypedMultiplicityRef2CS default=SINGLE_QUOTED_STRING?
		//	// FIXME QVTO syntax define a more complex InitPartCS	
		// ("opposites" "~"? opposite=Identifier)? // FIXME 
		//;
		@Override public ParserRule getRule() { return rule; }

		//stereotypes=StereotypeQualifierCS? qualifiers+=FeatureQualifier* name=UnrestrictedName ":"
		//ownedType=TypedMultiplicityRef2CS default=SINGLE_QUOTED_STRING?
		//// FIXME QVTO syntax define a more complex InitPartCS	
		// ("opposites" "~"? opposite=Identifier)? // FIXME
		public Group getGroup() { return cGroup; }

		//stereotypes=StereotypeQualifierCS?
		public Assignment getStereotypesAssignment_0() { return cStereotypesAssignment_0; }

		//StereotypeQualifierCS
		public RuleCall getStereotypesStereotypeQualifierCSParserRuleCall_0_0() { return cStereotypesStereotypeQualifierCSParserRuleCall_0_0; }

		//qualifiers+=FeatureQualifier*
		public Assignment getQualifiersAssignment_1() { return cQualifiersAssignment_1; }

		//FeatureQualifier
		public RuleCall getQualifiersFeatureQualifierParserRuleCall_1_0() { return cQualifiersFeatureQualifierParserRuleCall_1_0; }

		//name=UnrestrictedName
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }

		//UnrestrictedName
		public RuleCall getNameUnrestrictedNameParserRuleCall_2_0() { return cNameUnrestrictedNameParserRuleCall_2_0; }

		//":"
		public Keyword getColonKeyword_3() { return cColonKeyword_3; }

		//ownedType=TypedMultiplicityRef2CS
		public Assignment getOwnedTypeAssignment_4() { return cOwnedTypeAssignment_4; }

		//TypedMultiplicityRef2CS
		public RuleCall getOwnedTypeTypedMultiplicityRef2CSParserRuleCall_4_0() { return cOwnedTypeTypedMultiplicityRef2CSParserRuleCall_4_0; }

		//default=SINGLE_QUOTED_STRING?
		public Assignment getDefaultAssignment_5() { return cDefaultAssignment_5; }

		//SINGLE_QUOTED_STRING
		public RuleCall getDefaultSINGLE_QUOTED_STRINGTerminalRuleCall_5_0() { return cDefaultSINGLE_QUOTED_STRINGTerminalRuleCall_5_0; }

		//("opposites" "~"? opposite=Identifier)?
		public Group getGroup_6() { return cGroup_6; }

		//"opposites"
		public Keyword getOppositesKeyword_6_0() { return cOppositesKeyword_6_0; }

		//"~"?
		public Keyword getTildeKeyword_6_1() { return cTildeKeyword_6_1; }

		//opposite=Identifier
		public Assignment getOppositeAssignment_6_2() { return cOppositeAssignment_6_2; }

		//Identifier
		public RuleCall getOppositeIdentifierParserRuleCall_6_2_0() { return cOppositeIdentifierParserRuleCall_6_2_0; }
	}

	public class StereotypeQualifierCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "StereotypeQualifierCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLessThanSignLessThanSignKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cStereotypeAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cStereotypeIdentifierParserRuleCall_1_0_0 = (RuleCall)cStereotypeAssignment_1_0.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cGroup_1.eContents().get(1);
		private final Keyword cCommaKeyword_1_1_0 = (Keyword)cGroup_1_1.eContents().get(0);
		private final Assignment cStereotypeAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cStereotypeIdentifierParserRuleCall_1_1_1_0 = (RuleCall)cStereotypeAssignment_1_1_1.eContents().get(0);
		private final Keyword cGreaterThanSignGreaterThanSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//StereotypeQualifierCS:
		//	"<<" (stereotype+=Identifier ("," stereotype+=Identifier)*) ">>";
		@Override public ParserRule getRule() { return rule; }

		//"<<" (stereotype+=Identifier ("," stereotype+=Identifier)*) ">>"
		public Group getGroup() { return cGroup; }

		//"<<"
		public Keyword getLessThanSignLessThanSignKeyword_0() { return cLessThanSignLessThanSignKeyword_0; }

		//stereotype+=Identifier ("," stereotype+=Identifier)*
		public Group getGroup_1() { return cGroup_1; }

		//stereotype+=Identifier
		public Assignment getStereotypeAssignment_1_0() { return cStereotypeAssignment_1_0; }

		//Identifier
		public RuleCall getStereotypeIdentifierParserRuleCall_1_0_0() { return cStereotypeIdentifierParserRuleCall_1_0_0; }

		//("," stereotype+=Identifier)*
		public Group getGroup_1_1() { return cGroup_1_1; }

		//","
		public Keyword getCommaKeyword_1_1_0() { return cCommaKeyword_1_1_0; }

		//stereotype+=Identifier
		public Assignment getStereotypeAssignment_1_1_1() { return cStereotypeAssignment_1_1_1; }

		//Identifier
		public RuleCall getStereotypeIdentifierParserRuleCall_1_1_1_0() { return cStereotypeIdentifierParserRuleCall_1_1_1_0; }

		//">>"
		public Keyword getGreaterThanSignGreaterThanSignKeyword_2() { return cGreaterThanSignGreaterThanSignKeyword_2; }
	}

	public class MultiplicityCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MultiplicityCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cLowerBoundAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cLowerBoundLOWERParserRuleCall_1_0_0 = (RuleCall)cLowerBoundAssignment_1_0.eContents().get(0);
		private final Keyword cFullStopFullStopFullStopKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cUpperBoundAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cUpperBoundUPPERParserRuleCall_2_0 = (RuleCall)cUpperBoundAssignment_2.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//MultiplicityCS returns base::MultiplicityBoundsCS:
		//	"[" (lowerBound=LOWER "...")? upperBound=UPPER "]";
		@Override public ParserRule getRule() { return rule; }

		//"[" (lowerBound=LOWER "...")? upperBound=UPPER "]"
		public Group getGroup() { return cGroup; }

		//"["
		public Keyword getLeftSquareBracketKeyword_0() { return cLeftSquareBracketKeyword_0; }

		//(lowerBound=LOWER "...")?
		public Group getGroup_1() { return cGroup_1; }

		//lowerBound=LOWER
		public Assignment getLowerBoundAssignment_1_0() { return cLowerBoundAssignment_1_0; }

		//LOWER
		public RuleCall getLowerBoundLOWERParserRuleCall_1_0_0() { return cLowerBoundLOWERParserRuleCall_1_0_0; }

		//"..."
		public Keyword getFullStopFullStopFullStopKeyword_1_1() { return cFullStopFullStopFullStopKeyword_1_1; }

		//upperBound=UPPER
		public Assignment getUpperBoundAssignment_2() { return cUpperBoundAssignment_2; }

		//UPPER
		public RuleCall getUpperBoundUPPERParserRuleCall_2_0() { return cUpperBoundUPPERParserRuleCall_2_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_3() { return cRightSquareBracketKeyword_3; }
	}

	public class ClassifierOperationCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ClassifierOperationCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cStereotypesAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cStereotypesStereotypeQualifierCSParserRuleCall_0_0 = (RuleCall)cStereotypesAssignment_0.eContents().get(0);
		private final Assignment cQualifiersAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cQualifiersFeatureQualifierParserRuleCall_1_0 = (RuleCall)cQualifiersAssignment_1.eContents().get(0);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameUnrestrictedNameParserRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Assignment cOwnedParametersAssignment_4_0 = (Assignment)cGroup_4.eContents().get(0);
		private final RuleCall cOwnedParametersParameterCSParserRuleCall_4_0_0 = (RuleCall)cOwnedParametersAssignment_4_0.eContents().get(0);
		private final Group cGroup_4_1 = (Group)cGroup_4.eContents().get(1);
		private final Keyword cCommaKeyword_4_1_0 = (Keyword)cGroup_4_1.eContents().get(0);
		private final Assignment cOwnedParametersAssignment_4_1_1 = (Assignment)cGroup_4_1.eContents().get(1);
		private final RuleCall cOwnedParametersParameterCSParserRuleCall_4_1_1_0 = (RuleCall)cOwnedParametersAssignment_4_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Group cGroup_6 = (Group)cGroup.eContents().get(6);
		private final Keyword cColonKeyword_6_0 = (Keyword)cGroup_6.eContents().get(0);
		private final Assignment cOwnedTypeAssignment_6_1 = (Assignment)cGroup_6.eContents().get(1);
		private final RuleCall cOwnedTypeTypedMultiplicityRef2CSParserRuleCall_6_1_0 = (RuleCall)cOwnedTypeAssignment_6_1.eContents().get(0);
		
		//ClassifierOperationCS returns QVToOperationCS:
		//	stereotypes=StereotypeQualifierCS? qualifiers+=FeatureQualifier* name=UnrestrictedName "("
		//	(ownedParameters+=ParameterCS ("," ownedParameters+=ParameterCS)*)? ")" (":" ownedType=TypedMultiplicityRef2CS)?;
		@Override public ParserRule getRule() { return rule; }

		//stereotypes=StereotypeQualifierCS? qualifiers+=FeatureQualifier* name=UnrestrictedName "(" (ownedParameters+=ParameterCS
		//("," ownedParameters+=ParameterCS)*)? ")" (":" ownedType=TypedMultiplicityRef2CS)?
		public Group getGroup() { return cGroup; }

		//stereotypes=StereotypeQualifierCS?
		public Assignment getStereotypesAssignment_0() { return cStereotypesAssignment_0; }

		//StereotypeQualifierCS
		public RuleCall getStereotypesStereotypeQualifierCSParserRuleCall_0_0() { return cStereotypesStereotypeQualifierCSParserRuleCall_0_0; }

		//qualifiers+=FeatureQualifier*
		public Assignment getQualifiersAssignment_1() { return cQualifiersAssignment_1; }

		//FeatureQualifier
		public RuleCall getQualifiersFeatureQualifierParserRuleCall_1_0() { return cQualifiersFeatureQualifierParserRuleCall_1_0; }

		//name=UnrestrictedName
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }

		//UnrestrictedName
		public RuleCall getNameUnrestrictedNameParserRuleCall_2_0() { return cNameUnrestrictedNameParserRuleCall_2_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_3() { return cLeftParenthesisKeyword_3; }

		//(ownedParameters+=ParameterCS ("," ownedParameters+=ParameterCS)*)?
		public Group getGroup_4() { return cGroup_4; }

		//ownedParameters+=ParameterCS
		public Assignment getOwnedParametersAssignment_4_0() { return cOwnedParametersAssignment_4_0; }

		//ParameterCS
		public RuleCall getOwnedParametersParameterCSParserRuleCall_4_0_0() { return cOwnedParametersParameterCSParserRuleCall_4_0_0; }

		//("," ownedParameters+=ParameterCS)*
		public Group getGroup_4_1() { return cGroup_4_1; }

		//","
		public Keyword getCommaKeyword_4_1_0() { return cCommaKeyword_4_1_0; }

		//ownedParameters+=ParameterCS
		public Assignment getOwnedParametersAssignment_4_1_1() { return cOwnedParametersAssignment_4_1_1; }

		//ParameterCS
		public RuleCall getOwnedParametersParameterCSParserRuleCall_4_1_1_0() { return cOwnedParametersParameterCSParserRuleCall_4_1_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }

		//(":" ownedType=TypedMultiplicityRef2CS)?
		public Group getGroup_6() { return cGroup_6; }

		//":"
		public Keyword getColonKeyword_6_0() { return cColonKeyword_6_0; }

		//ownedType=TypedMultiplicityRef2CS
		public Assignment getOwnedTypeAssignment_6_1() { return cOwnedTypeAssignment_6_1; }

		//TypedMultiplicityRef2CS
		public RuleCall getOwnedTypeTypedMultiplicityRef2CSParserRuleCall_6_1_0() { return cOwnedTypeTypedMultiplicityRef2CSParserRuleCall_6_1_0; }
	}

	public class EnumerationCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EnumerationCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cEnumKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIdentifierParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cLeftCurlyBracketKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Assignment cOwnedLiteralsAssignment_2_1_0 = (Assignment)cGroup_2_1.eContents().get(0);
		private final RuleCall cOwnedLiteralsEnumerationLiteralCSParserRuleCall_2_1_0_0 = (RuleCall)cOwnedLiteralsAssignment_2_1_0.eContents().get(0);
		private final Group cGroup_2_1_1 = (Group)cGroup_2_1.eContents().get(1);
		private final Keyword cCommaKeyword_2_1_1_0 = (Keyword)cGroup_2_1_1.eContents().get(0);
		private final Assignment cOwnedLiteralsAssignment_2_1_1_1 = (Assignment)cGroup_2_1_1.eContents().get(1);
		private final RuleCall cOwnedLiteralsEnumerationLiteralCSParserRuleCall_2_1_1_1_0 = (RuleCall)cOwnedLiteralsAssignment_2_1_1_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_2_2 = (Keyword)cGroup_2.eContents().get(2);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//// FIXME Deviation from official grammar
		// EnumerationCS returns base::EnumerationCS:
		//	"enum" name=Identifier ("{" (ownedLiterals+=EnumerationLiteralCS ("," ownedLiterals+=EnumerationLiteralCS)*) "}")
		//	";"?;
		@Override public ParserRule getRule() { return rule; }

		//"enum" name=Identifier ("{" (ownedLiterals+=EnumerationLiteralCS ("," ownedLiterals+=EnumerationLiteralCS)*) "}") ";"?
		public Group getGroup() { return cGroup; }

		//"enum"
		public Keyword getEnumKeyword_0() { return cEnumKeyword_0; }

		//name=Identifier
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//Identifier
		public RuleCall getNameIdentifierParserRuleCall_1_0() { return cNameIdentifierParserRuleCall_1_0; }

		//"{" (ownedLiterals+=EnumerationLiteralCS ("," ownedLiterals+=EnumerationLiteralCS)*) "}"
		public Group getGroup_2() { return cGroup_2; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_2_0() { return cLeftCurlyBracketKeyword_2_0; }

		//ownedLiterals+=EnumerationLiteralCS ("," ownedLiterals+=EnumerationLiteralCS)*
		public Group getGroup_2_1() { return cGroup_2_1; }

		//ownedLiterals+=EnumerationLiteralCS
		public Assignment getOwnedLiteralsAssignment_2_1_0() { return cOwnedLiteralsAssignment_2_1_0; }

		//EnumerationLiteralCS
		public RuleCall getOwnedLiteralsEnumerationLiteralCSParserRuleCall_2_1_0_0() { return cOwnedLiteralsEnumerationLiteralCSParserRuleCall_2_1_0_0; }

		//("," ownedLiterals+=EnumerationLiteralCS)*
		public Group getGroup_2_1_1() { return cGroup_2_1_1; }

		//","
		public Keyword getCommaKeyword_2_1_1_0() { return cCommaKeyword_2_1_1_0; }

		//ownedLiterals+=EnumerationLiteralCS
		public Assignment getOwnedLiteralsAssignment_2_1_1_1() { return cOwnedLiteralsAssignment_2_1_1_1; }

		//EnumerationLiteralCS
		public RuleCall getOwnedLiteralsEnumerationLiteralCSParserRuleCall_2_1_1_1_0() { return cOwnedLiteralsEnumerationLiteralCSParserRuleCall_2_1_1_1_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_2_2() { return cRightCurlyBracketKeyword_2_2; }

		//";"?
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
	}

	public class EnumerationLiteralCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EnumerationLiteralCS");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameUnrestrictedNameParserRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//EnumerationLiteralCS returns base::EnumerationLiteralCS:
		//	name=UnrestrictedName;
		@Override public ParserRule getRule() { return rule; }

		//name=UnrestrictedName
		public Assignment getNameAssignment() { return cNameAssignment; }

		//UnrestrictedName
		public RuleCall getNameUnrestrictedNameParserRuleCall_0() { return cNameUnrestrictedNameParserRuleCall_0; }
	}

	public class TagCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TagCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cTagKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Alternatives cNameAlternatives_1_0 = (Alternatives)cNameAssignment_1.eContents().get(0);
		private final RuleCall cNameUnrestrictedNameParserRuleCall_1_0_0 = (RuleCall)cNameAlternatives_1_0.eContents().get(0);
		private final RuleCall cNameSINGLE_QUOTED_STRINGTerminalRuleCall_1_0_1 = (RuleCall)cNameAlternatives_1_0.eContents().get(1);
		private final Assignment cElementPathAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cElementPathPathName2CSParserRuleCall_2_0 = (RuleCall)cElementPathAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cEqualsSignKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cExpressionAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cExpressionExpCSParserRuleCall_3_1_0 = (RuleCall)cExpressionAssignment_3_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//TagCS:
		//	"tag" name=(UnrestrictedName | SINGLE_QUOTED_STRING)? elementPath=PathName2CS ("=" expression=ExpCS)? ";";
		@Override public ParserRule getRule() { return rule; }

		//"tag" name=(UnrestrictedName | SINGLE_QUOTED_STRING)? elementPath=PathName2CS ("=" expression=ExpCS)? ";"
		public Group getGroup() { return cGroup; }

		//"tag"
		public Keyword getTagKeyword_0() { return cTagKeyword_0; }

		//name=(UnrestrictedName | SINGLE_QUOTED_STRING)?
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//UnrestrictedName | SINGLE_QUOTED_STRING
		public Alternatives getNameAlternatives_1_0() { return cNameAlternatives_1_0; }

		//UnrestrictedName
		public RuleCall getNameUnrestrictedNameParserRuleCall_1_0_0() { return cNameUnrestrictedNameParserRuleCall_1_0_0; }

		//SINGLE_QUOTED_STRING
		public RuleCall getNameSINGLE_QUOTED_STRINGTerminalRuleCall_1_0_1() { return cNameSINGLE_QUOTED_STRINGTerminalRuleCall_1_0_1; }

		//elementPath=PathName2CS
		public Assignment getElementPathAssignment_2() { return cElementPathAssignment_2; }

		//PathName2CS
		public RuleCall getElementPathPathName2CSParserRuleCall_2_0() { return cElementPathPathName2CSParserRuleCall_2_0; }

		//("=" expression=ExpCS)?
		public Group getGroup_3() { return cGroup_3; }

		//"="
		public Keyword getEqualsSignKeyword_3_0() { return cEqualsSignKeyword_3_0; }

		//expression=ExpCS
		public Assignment getExpressionAssignment_3_1() { return cExpressionAssignment_3_1; }

		//ExpCS
		public RuleCall getExpressionExpCSParserRuleCall_3_1_0() { return cExpressionExpCSParserRuleCall_3_1_0; }

		//";"
		public Keyword getSemicolonKeyword_4() { return cSemicolonKeyword_4; }
	}

	public class ModuleRefCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ModuleRefCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cModulePathAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cModulePathPathName2CSParserRuleCall_0_0 = (RuleCall)cModulePathAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cParametersAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cParametersParameterDeclarationCSParserRuleCall_1_1_0 = (RuleCall)cParametersAssignment_1_1.eContents().get(0);
		private final Group cGroup_1_2 = (Group)cGroup_1.eContents().get(2);
		private final Keyword cCommaKeyword_1_2_0 = (Keyword)cGroup_1_2.eContents().get(0);
		private final Assignment cParametersAssignment_1_2_1 = (Assignment)cGroup_1_2.eContents().get(1);
		private final RuleCall cParametersParameterDeclarationCSParserRuleCall_1_2_1_0 = (RuleCall)cParametersAssignment_1_2_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		
		//// typedefs
		// // TypedefCS: 'typedef' name=Identifier '=' typespec=TypeExpCS ('[' condition=ExpCS ']')? ';';
		//
		//// ****** Transformation and Linbary imports
		// ModuleRefCS:
		//	modulePath=PathName2CS ("(" parameters+=ParameterDeclarationCS ("," parameters+=ParameterDeclarationCS)* ")")?;
		@Override public ParserRule getRule() { return rule; }

		//modulePath=PathName2CS ("(" parameters+=ParameterDeclarationCS ("," parameters+=ParameterDeclarationCS)* ")")?
		public Group getGroup() { return cGroup; }

		//modulePath=PathName2CS
		public Assignment getModulePathAssignment_0() { return cModulePathAssignment_0; }

		//PathName2CS
		public RuleCall getModulePathPathName2CSParserRuleCall_0_0() { return cModulePathPathName2CSParserRuleCall_0_0; }

		//("(" parameters+=ParameterDeclarationCS ("," parameters+=ParameterDeclarationCS)* ")")?
		public Group getGroup_1() { return cGroup_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_1_0() { return cLeftParenthesisKeyword_1_0; }

		//parameters+=ParameterDeclarationCS
		public Assignment getParametersAssignment_1_1() { return cParametersAssignment_1_1; }

		//ParameterDeclarationCS
		public RuleCall getParametersParameterDeclarationCSParserRuleCall_1_1_0() { return cParametersParameterDeclarationCSParserRuleCall_1_1_0; }

		//("," parameters+=ParameterDeclarationCS)*
		public Group getGroup_1_2() { return cGroup_1_2; }

		//","
		public Keyword getCommaKeyword_1_2_0() { return cCommaKeyword_1_2_0; }

		//parameters+=ParameterDeclarationCS
		public Assignment getParametersAssignment_1_2_1() { return cParametersAssignment_1_2_1; }

		//ParameterDeclarationCS
		public RuleCall getParametersParameterDeclarationCSParserRuleCall_1_2_1_0() { return cParametersParameterDeclarationCSParserRuleCall_1_2_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_1_3() { return cRightParenthesisKeyword_1_3; }
	}

	public class ModuleUsageCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ModuleUsageCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cImportKindAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cImportKindImportKindEnumEnumRuleCall_0_0 = (RuleCall)cImportKindAssignment_0.eContents().get(0);
		private final Assignment cModuleKindAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cModuleKindModuleKindEnumEnumRuleCall_1_0 = (RuleCall)cModuleKindAssignment_1.eContents().get(0);
		private final Assignment cModuleRefsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cModuleRefsModuleRefCSParserRuleCall_2_0 = (RuleCall)cModuleRefsAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cCommaKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cModuleRefsAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cModuleRefsModuleRefCSParserRuleCall_3_1_0 = (RuleCall)cModuleRefsAssignment_3_1.eContents().get(0);
		
		//ModuleUsageCS:
		//	importKind=ImportKindEnum moduleKind=ModuleKindEnum? moduleRefs+=ModuleRefCS ("," moduleRefs+=ModuleRefCS)*;
		@Override public ParserRule getRule() { return rule; }

		//importKind=ImportKindEnum moduleKind=ModuleKindEnum? moduleRefs+=ModuleRefCS ("," moduleRefs+=ModuleRefCS)*
		public Group getGroup() { return cGroup; }

		//importKind=ImportKindEnum
		public Assignment getImportKindAssignment_0() { return cImportKindAssignment_0; }

		//ImportKindEnum
		public RuleCall getImportKindImportKindEnumEnumRuleCall_0_0() { return cImportKindImportKindEnumEnumRuleCall_0_0; }

		//moduleKind=ModuleKindEnum?
		public Assignment getModuleKindAssignment_1() { return cModuleKindAssignment_1; }

		//ModuleKindEnum
		public RuleCall getModuleKindModuleKindEnumEnumRuleCall_1_0() { return cModuleKindModuleKindEnumEnumRuleCall_1_0; }

		//moduleRefs+=ModuleRefCS
		public Assignment getModuleRefsAssignment_2() { return cModuleRefsAssignment_2; }

		//ModuleRefCS
		public RuleCall getModuleRefsModuleRefCSParserRuleCall_2_0() { return cModuleRefsModuleRefCSParserRuleCall_2_0; }

		//("," moduleRefs+=ModuleRefCS)*
		public Group getGroup_3() { return cGroup_3; }

		//","
		public Keyword getCommaKeyword_3_0() { return cCommaKeyword_3_0; }

		//moduleRefs+=ModuleRefCS
		public Assignment getModuleRefsAssignment_3_1() { return cModuleRefsAssignment_3_1; }

		//ModuleRefCS
		public RuleCall getModuleRefsModuleRefCSParserRuleCall_3_1_0() { return cModuleRefsModuleRefCSParserRuleCall_3_1_0; }
	}

	public class TransformationCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TransformationCS");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cTransformationDeclCSParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cTransformationDefCSParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//// ****** Transformations, mappings, etc ******
		// TransformationCS:
		//	TransformationDeclCS | TransformationDefCS;
		@Override public ParserRule getRule() { return rule; }

		//TransformationDeclCS | TransformationDefCS
		public Alternatives getAlternatives() { return cAlternatives; }

		//TransformationDeclCS
		public RuleCall getTransformationDeclCSParserRuleCall_0() { return cTransformationDeclCSParserRuleCall_0; }

		//TransformationDefCS
		public RuleCall getTransformationDefCSParserRuleCall_1() { return cTransformationDefCSParserRuleCall_1; }
	}

	public class TransformationDeclCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TransformationDeclCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cTransformationHeaderCSParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Keyword cSemicolonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//TransformationDeclCS returns TransformationCS:
		//	TransformationHeaderCS ";";
		@Override public ParserRule getRule() { return rule; }

		//TransformationHeaderCS ";"
		public Group getGroup() { return cGroup; }

		//TransformationHeaderCS
		public RuleCall getTransformationHeaderCSParserRuleCall_0() { return cTransformationHeaderCSParserRuleCall_0; }

		//";"
		public Keyword getSemicolonKeyword_1() { return cSemicolonKeyword_1; }
	}

	public class TransformationDefCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TransformationDefCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cTransformationHeaderCSParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Assignment cOwnedPropertiesAssignment_2_0 = (Assignment)cAlternatives_2.eContents().get(0);
		private final RuleCall cOwnedPropertiesModulePropertyCSParserRuleCall_2_0_0 = (RuleCall)cOwnedPropertiesAssignment_2_0.eContents().get(0);
		private final Assignment cOwnedOperationsAssignment_2_1 = (Assignment)cAlternatives_2.eContents().get(1);
		private final RuleCall cOwnedOperationsModuleOperationCSParserRuleCall_2_1_0 = (RuleCall)cOwnedOperationsAssignment_2_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Keyword cSemicolonKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//TransformationDefCS returns TransformationCS:
		//	TransformationHeaderCS "{" (ownedProperties+=ModulePropertyCS
		//	// (ownedClasses+= ModuleTypeCS)* FIXME Transformation is not a package anymore. Not allowed
		// |
		//	ownedOperations+=ModuleOperationCS)* "}" ";"?;
		@Override public ParserRule getRule() { return rule; }

		//TransformationHeaderCS "{" (ownedProperties+=ModulePropertyCS
		//// (ownedClasses+= ModuleTypeCS)* FIXME Transformation is not a package anymore. Not allowed
		// |
		//ownedOperations+=ModuleOperationCS)* "}" ";"?
		public Group getGroup() { return cGroup; }

		//TransformationHeaderCS
		public RuleCall getTransformationHeaderCSParserRuleCall_0() { return cTransformationHeaderCSParserRuleCall_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }

		//(ownedProperties+=ModulePropertyCS
		//// (ownedClasses+= ModuleTypeCS)* FIXME Transformation is not a package anymore. Not allowed
		// |
		//ownedOperations+=ModuleOperationCS)*
		public Alternatives getAlternatives_2() { return cAlternatives_2; }

		//ownedProperties+=ModulePropertyCS
		public Assignment getOwnedPropertiesAssignment_2_0() { return cOwnedPropertiesAssignment_2_0; }

		//ModulePropertyCS
		public RuleCall getOwnedPropertiesModulePropertyCSParserRuleCall_2_0_0() { return cOwnedPropertiesModulePropertyCSParserRuleCall_2_0_0; }

		//ownedOperations+=ModuleOperationCS
		public Assignment getOwnedOperationsAssignment_2_1() { return cOwnedOperationsAssignment_2_1; }

		//ModuleOperationCS
		public RuleCall getOwnedOperationsModuleOperationCSParserRuleCall_2_1_0() { return cOwnedOperationsModuleOperationCSParserRuleCall_2_1_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_3() { return cRightCurlyBracketKeyword_3; }

		//";"?
		public Keyword getSemicolonKeyword_4() { return cSemicolonKeyword_4; }
	}

	public class TransformationHeaderCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TransformationHeaderCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cQualifiersAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cQualifiersTransformationQualifierParserRuleCall_0_0 = (RuleCall)cQualifiersAssignment_0.eContents().get(0);
		private final Keyword cTransformationKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameUnrestrictedNameParserRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cParametersAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cParametersParameterDeclarationCSParserRuleCall_4_0 = (RuleCall)cParametersAssignment_4.eContents().get(0);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Keyword cCommaKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final Assignment cParametersAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final RuleCall cParametersParameterDeclarationCSParserRuleCall_5_1_0 = (RuleCall)cParametersAssignment_5_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Assignment cModuleUsagesAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final RuleCall cModuleUsagesModuleUsageCSParserRuleCall_7_0 = (RuleCall)cModuleUsagesAssignment_7.eContents().get(0);
		private final Group cGroup_8 = (Group)cGroup.eContents().get(8);
		private final Keyword cRefinesKeyword_8_0 = (Keyword)cGroup_8.eContents().get(0);
		private final Assignment cRefinesAssignment_8_1 = (Assignment)cGroup_8.eContents().get(1);
		private final RuleCall cRefinesModuleRefCSParserRuleCall_8_1_0 = (RuleCall)cRefinesAssignment_8_1.eContents().get(0);
		
		//TransformationHeaderCS returns TransformationCS:
		//	qualifiers+=TransformationQualifier* "transformation" name=UnrestrictedName "(" parameters+=ParameterDeclarationCS
		//	("," parameters+=ParameterDeclarationCS)* ")" moduleUsages+=ModuleUsageCS* ("refines" refines=ModuleRefCS)?;
		@Override public ParserRule getRule() { return rule; }

		//qualifiers+=TransformationQualifier* "transformation" name=UnrestrictedName "(" parameters+=ParameterDeclarationCS (","
		//parameters+=ParameterDeclarationCS)* ")" moduleUsages+=ModuleUsageCS* ("refines" refines=ModuleRefCS)?
		public Group getGroup() { return cGroup; }

		//qualifiers+=TransformationQualifier*
		public Assignment getQualifiersAssignment_0() { return cQualifiersAssignment_0; }

		//TransformationQualifier
		public RuleCall getQualifiersTransformationQualifierParserRuleCall_0_0() { return cQualifiersTransformationQualifierParserRuleCall_0_0; }

		//"transformation"
		public Keyword getTransformationKeyword_1() { return cTransformationKeyword_1; }

		//name=UnrestrictedName
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }

		//UnrestrictedName
		public RuleCall getNameUnrestrictedNameParserRuleCall_2_0() { return cNameUnrestrictedNameParserRuleCall_2_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_3() { return cLeftParenthesisKeyword_3; }

		//parameters+=ParameterDeclarationCS
		public Assignment getParametersAssignment_4() { return cParametersAssignment_4; }

		//ParameterDeclarationCS
		public RuleCall getParametersParameterDeclarationCSParserRuleCall_4_0() { return cParametersParameterDeclarationCSParserRuleCall_4_0; }

		//("," parameters+=ParameterDeclarationCS)*
		public Group getGroup_5() { return cGroup_5; }

		//","
		public Keyword getCommaKeyword_5_0() { return cCommaKeyword_5_0; }

		//parameters+=ParameterDeclarationCS
		public Assignment getParametersAssignment_5_1() { return cParametersAssignment_5_1; }

		//ParameterDeclarationCS
		public RuleCall getParametersParameterDeclarationCSParserRuleCall_5_1_0() { return cParametersParameterDeclarationCSParserRuleCall_5_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_6() { return cRightParenthesisKeyword_6; }

		//moduleUsages+=ModuleUsageCS*
		public Assignment getModuleUsagesAssignment_7() { return cModuleUsagesAssignment_7; }

		//ModuleUsageCS
		public RuleCall getModuleUsagesModuleUsageCSParserRuleCall_7_0() { return cModuleUsagesModuleUsageCSParserRuleCall_7_0; }

		//("refines" refines=ModuleRefCS)?
		public Group getGroup_8() { return cGroup_8; }

		//"refines"
		public Keyword getRefinesKeyword_8_0() { return cRefinesKeyword_8_0; }

		//refines=ModuleRefCS
		public Assignment getRefinesAssignment_8_1() { return cRefinesAssignment_8_1; }

		//ModuleRefCS
		public RuleCall getRefinesModuleRefCSParserRuleCall_8_1_0() { return cRefinesModuleRefCSParserRuleCall_8_1_0; }
	}

	public class LibraryCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LibraryCS");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cLibraryDeclCSParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cLibraryDefCSParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//LibraryCS returns QVToLibraryCS:
		//	LibraryDeclCS | LibraryDefCS;
		@Override public ParserRule getRule() { return rule; }

		//LibraryDeclCS | LibraryDefCS
		public Alternatives getAlternatives() { return cAlternatives; }

		//LibraryDeclCS
		public RuleCall getLibraryDeclCSParserRuleCall_0() { return cLibraryDeclCSParserRuleCall_0; }

		//LibraryDefCS
		public RuleCall getLibraryDefCSParserRuleCall_1() { return cLibraryDefCSParserRuleCall_1; }
	}

	public class LibraryDeclCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LibraryDeclCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cLibraryHeaderCSParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Keyword cSemicolonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//LibraryDeclCS returns QVToLibraryCS:
		//	LibraryHeaderCS ";";
		@Override public ParserRule getRule() { return rule; }

		//LibraryHeaderCS ";"
		public Group getGroup() { return cGroup; }

		//LibraryHeaderCS
		public RuleCall getLibraryHeaderCSParserRuleCall_0() { return cLibraryHeaderCSParserRuleCall_0; }

		//";"
		public Keyword getSemicolonKeyword_1() { return cSemicolonKeyword_1; }
	}

	public class LibraryDefCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LibraryDefCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cLibraryHeaderCSParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Assignment cOwnedPropertiesAssignment_2_0 = (Assignment)cAlternatives_2.eContents().get(0);
		private final RuleCall cOwnedPropertiesModulePropertyCSParserRuleCall_2_0_0 = (RuleCall)cOwnedPropertiesAssignment_2_0.eContents().get(0);
		private final Assignment cOwnedOperationsAssignment_2_1 = (Assignment)cAlternatives_2.eContents().get(1);
		private final RuleCall cOwnedOperationsModuleOperationCSParserRuleCall_2_1_0 = (RuleCall)cOwnedOperationsAssignment_2_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Keyword cSemicolonKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//LibraryDefCS returns QVToLibraryCS:
		//	LibraryHeaderCS "{" (ownedProperties+=ModulePropertyCS | ownedOperations+=ModuleOperationCS)* "}" ";"?;
		@Override public ParserRule getRule() { return rule; }

		//LibraryHeaderCS "{" (ownedProperties+=ModulePropertyCS | ownedOperations+=ModuleOperationCS)* "}" ";"?
		public Group getGroup() { return cGroup; }

		//LibraryHeaderCS
		public RuleCall getLibraryHeaderCSParserRuleCall_0() { return cLibraryHeaderCSParserRuleCall_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }

		//(ownedProperties+=ModulePropertyCS | ownedOperations+=ModuleOperationCS)*
		public Alternatives getAlternatives_2() { return cAlternatives_2; }

		//ownedProperties+=ModulePropertyCS
		public Assignment getOwnedPropertiesAssignment_2_0() { return cOwnedPropertiesAssignment_2_0; }

		//ModulePropertyCS
		public RuleCall getOwnedPropertiesModulePropertyCSParserRuleCall_2_0_0() { return cOwnedPropertiesModulePropertyCSParserRuleCall_2_0_0; }

		//ownedOperations+=ModuleOperationCS
		public Assignment getOwnedOperationsAssignment_2_1() { return cOwnedOperationsAssignment_2_1; }

		//ModuleOperationCS
		public RuleCall getOwnedOperationsModuleOperationCSParserRuleCall_2_1_0() { return cOwnedOperationsModuleOperationCSParserRuleCall_2_1_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_3() { return cRightCurlyBracketKeyword_3; }

		//";"?
		public Keyword getSemicolonKeyword_4() { return cSemicolonKeyword_4; }
	}

	public class LibraryHeaderCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LibraryHeaderCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cQualifiersAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cQualifiersLibraryQualifierParserRuleCall_0_0 = (RuleCall)cQualifiersAssignment_0.eContents().get(0);
		private final Keyword cLibraryKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameUnrestrictedNameParserRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cParametersAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cParametersModelTypeRefCSParserRuleCall_4_0 = (RuleCall)cParametersAssignment_4.eContents().get(0);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Keyword cCommaKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final Assignment cParametersAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final RuleCall cParametersModelTypeRefCSParserRuleCall_5_1_0 = (RuleCall)cParametersAssignment_5_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Assignment cModuleUsagesAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final RuleCall cModuleUsagesModuleUsageCSParserRuleCall_7_0 = (RuleCall)cModuleUsagesAssignment_7.eContents().get(0);
		
		//LibraryHeaderCS returns QVToLibraryCS:
		//	qualifiers+=LibraryQualifier* "library" name=UnrestrictedName "(" parameters+=ModelTypeRefCS (","
		//	parameters+=ModelTypeRefCS)* ")" moduleUsages+=ModuleUsageCS*;
		@Override public ParserRule getRule() { return rule; }

		//qualifiers+=LibraryQualifier* "library" name=UnrestrictedName "(" parameters+=ModelTypeRefCS (","
		//parameters+=ModelTypeRefCS)* ")" moduleUsages+=ModuleUsageCS*
		public Group getGroup() { return cGroup; }

		//qualifiers+=LibraryQualifier*
		public Assignment getQualifiersAssignment_0() { return cQualifiersAssignment_0; }

		//LibraryQualifier
		public RuleCall getQualifiersLibraryQualifierParserRuleCall_0_0() { return cQualifiersLibraryQualifierParserRuleCall_0_0; }

		//"library"
		public Keyword getLibraryKeyword_1() { return cLibraryKeyword_1; }

		//name=UnrestrictedName
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }

		//UnrestrictedName
		public RuleCall getNameUnrestrictedNameParserRuleCall_2_0() { return cNameUnrestrictedNameParserRuleCall_2_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_3() { return cLeftParenthesisKeyword_3; }

		//parameters+=ModelTypeRefCS
		public Assignment getParametersAssignment_4() { return cParametersAssignment_4; }

		//ModelTypeRefCS
		public RuleCall getParametersModelTypeRefCSParserRuleCall_4_0() { return cParametersModelTypeRefCSParserRuleCall_4_0; }

		//("," parameters+=ModelTypeRefCS)*
		public Group getGroup_5() { return cGroup_5; }

		//","
		public Keyword getCommaKeyword_5_0() { return cCommaKeyword_5_0; }

		//parameters+=ModelTypeRefCS
		public Assignment getParametersAssignment_5_1() { return cParametersAssignment_5_1; }

		//ModelTypeRefCS
		public RuleCall getParametersModelTypeRefCSParserRuleCall_5_1_0() { return cParametersModelTypeRefCSParserRuleCall_5_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_6() { return cRightParenthesisKeyword_6; }

		//moduleUsages+=ModuleUsageCS*
		public Assignment getModuleUsagesAssignment_7() { return cModuleUsagesAssignment_7; }

		//ModuleUsageCS
		public RuleCall getModuleUsagesModuleUsageCSParserRuleCall_7_0() { return cModuleUsagesModuleUsageCSParserRuleCall_7_0; }
	}

	public class ModelTypeCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ModelTypeCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cModeltypeKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameUnrestrictedNameParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Assignment cComplianceKindAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cComplianceKindStringLiteralParserRuleCall_2_0 = (RuleCall)cComplianceKindAssignment_2.eContents().get(0);
		private final Keyword cUsesKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cPackageRefsAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cPackageRefsPackageRefCSParserRuleCall_4_0 = (RuleCall)cPackageRefsAssignment_4.eContents().get(0);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Keyword cCommaKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final Assignment cPackageRefsAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final RuleCall cPackageRefsPackageRefCSParserRuleCall_5_1_0 = (RuleCall)cPackageRefsAssignment_5_1.eContents().get(0);
		private final Group cGroup_6 = (Group)cGroup.eContents().get(6);
		private final Keyword cWhereKeyword_6_0 = (Keyword)cGroup_6.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_6_1 = (Keyword)cGroup_6.eContents().get(1);
		private final Keyword cRightCurlyBracketKeyword_6_2 = (Keyword)cGroup_6.eContents().get(2);
		private final Keyword cSemicolonKeyword_7 = (Keyword)cGroup.eContents().get(7);
		
		//ModelTypeCS:
		//	"modeltype" name=UnrestrictedName complianceKind=StringLiteral? "uses" packageRefs+=PackageRefCS (","
		//	packageRefs+=PackageRefCS)* ("where" "{" / *TODO (whereStatements+=ExpCS (';' whereStatements+=ExpCS)* ';'?))? * /
		//	"}")? ";";
		@Override public ParserRule getRule() { return rule; }

		//"modeltype" name=UnrestrictedName complianceKind=StringLiteral? "uses" packageRefs+=PackageRefCS (","
		//packageRefs+=PackageRefCS)* ("where" "{" / *TODO (whereStatements+=ExpCS (';' whereStatements+=ExpCS)* ';'?))? * / "}")?
		//";"
		public Group getGroup() { return cGroup; }

		//"modeltype"
		public Keyword getModeltypeKeyword_0() { return cModeltypeKeyword_0; }

		//name=UnrestrictedName
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//UnrestrictedName
		public RuleCall getNameUnrestrictedNameParserRuleCall_1_0() { return cNameUnrestrictedNameParserRuleCall_1_0; }

		//complianceKind=StringLiteral?
		public Assignment getComplianceKindAssignment_2() { return cComplianceKindAssignment_2; }

		//StringLiteral
		public RuleCall getComplianceKindStringLiteralParserRuleCall_2_0() { return cComplianceKindStringLiteralParserRuleCall_2_0; }

		//"uses"
		public Keyword getUsesKeyword_3() { return cUsesKeyword_3; }

		//packageRefs+=PackageRefCS
		public Assignment getPackageRefsAssignment_4() { return cPackageRefsAssignment_4; }

		//PackageRefCS
		public RuleCall getPackageRefsPackageRefCSParserRuleCall_4_0() { return cPackageRefsPackageRefCSParserRuleCall_4_0; }

		//("," packageRefs+=PackageRefCS)*
		public Group getGroup_5() { return cGroup_5; }

		//","
		public Keyword getCommaKeyword_5_0() { return cCommaKeyword_5_0; }

		//packageRefs+=PackageRefCS
		public Assignment getPackageRefsAssignment_5_1() { return cPackageRefsAssignment_5_1; }

		//PackageRefCS
		public RuleCall getPackageRefsPackageRefCSParserRuleCall_5_1_0() { return cPackageRefsPackageRefCSParserRuleCall_5_1_0; }

		//("where" "{" / *TODO (whereStatements+=ExpCS (';' whereStatements+=ExpCS)* ';'?))? * / "}")?
		public Group getGroup_6() { return cGroup_6; }

		//"where"
		public Keyword getWhereKeyword_6_0() { return cWhereKeyword_6_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_6_1() { return cLeftCurlyBracketKeyword_6_1; }

		/// *TODO (whereStatements+=ExpCS (';' whereStatements+=ExpCS)* ';'?))? * / "}"
		public Keyword getRightCurlyBracketKeyword_6_2() { return cRightCurlyBracketKeyword_6_2; }

		//";"
		public Keyword getSemicolonKeyword_7() { return cSemicolonKeyword_7; }
	}

	public class ModelTypeRefCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ModelTypeRefCS");
		private final Assignment cOwnedTypeAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cOwnedTypeTypedTypeRef2CSParserRuleCall_0 = (RuleCall)cOwnedTypeAssignment.eContents().get(0);
		
		//ModelTypeRefCS:
		//	ownedType=TypedTypeRef2CS;
		@Override public ParserRule getRule() { return rule; }

		//ownedType=TypedTypeRef2CS
		public Assignment getOwnedTypeAssignment() { return cOwnedTypeAssignment; }

		//TypedTypeRef2CS
		public RuleCall getOwnedTypeTypedTypeRef2CSParserRuleCall_0() { return cOwnedTypeTypedTypeRef2CSParserRuleCall_0; }
	}

	public class PackageRefCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PackageRefCS");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cUriAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cUriStringLiteralExpCSParserRuleCall_0_0 = (RuleCall)cUriAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Assignment cPackagePathAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cPackagePathPathName2CSParserRuleCall_1_0_0 = (RuleCall)cPackagePathAssignment_1_0.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cUriAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cUriStringLiteralExpCSParserRuleCall_1_2_0 = (RuleCall)cUriAssignment_1_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		
		//PackageRefCS:
		//	uri=StringLiteralExpCS | packagePath=PathName2CS "(" uri=StringLiteralExpCS ")";
		@Override public ParserRule getRule() { return rule; }

		//uri=StringLiteralExpCS | packagePath=PathName2CS "(" uri=StringLiteralExpCS ")"
		public Alternatives getAlternatives() { return cAlternatives; }

		//uri=StringLiteralExpCS
		public Assignment getUriAssignment_0() { return cUriAssignment_0; }

		//StringLiteralExpCS
		public RuleCall getUriStringLiteralExpCSParserRuleCall_0_0() { return cUriStringLiteralExpCSParserRuleCall_0_0; }

		//packagePath=PathName2CS "(" uri=StringLiteralExpCS ")"
		public Group getGroup_1() { return cGroup_1; }

		//packagePath=PathName2CS
		public Assignment getPackagePathAssignment_1_0() { return cPackagePathAssignment_1_0; }

		//PathName2CS
		public RuleCall getPackagePathPathName2CSParserRuleCall_1_0_0() { return cPackagePathPathName2CSParserRuleCall_1_0_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1_1() { return cLeftParenthesisKeyword_1_1; }

		//uri=StringLiteralExpCS
		public Assignment getUriAssignment_1_2() { return cUriAssignment_1_2; }

		//StringLiteralExpCS
		public RuleCall getUriStringLiteralExpCSParserRuleCall_1_2_0() { return cUriStringLiteralExpCSParserRuleCall_1_2_0; }

		//")"
		public Keyword getRightParenthesisKeyword_1_3() { return cRightParenthesisKeyword_1_3; }
	}

	public class ModulePropertyCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ModulePropertyCS");
		private final RuleCall cClassifierPropertyCSParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//ModulePropertyCS returns base::StructuralFeatureCS:
		//	ClassifierPropertyCS;
		@Override public ParserRule getRule() { return rule; }

		//ClassifierPropertyCS
		public RuleCall getClassifierPropertyCSParserRuleCall() { return cClassifierPropertyCSParserRuleCall; }
	}

	public class ModuleOperationCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ModuleOperationCS");
		private final RuleCall cMappingOperationCSParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//ModuleOperationCS returns base::OperationCS:
		//	MappingOperationCS;
		@Override public ParserRule getRule() { return rule; }

		//MappingOperationCS
		public RuleCall getMappingOperationCSParserRuleCall() { return cMappingOperationCSParserRuleCall; }
	}

	public class MappingOperationCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MappingOperationCS");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cMappingDeclarationCSParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cMappingDefinitionCSParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//MappingOperationCS:
		//	MappingDeclarationCS | MappingDefinitionCS;
		@Override public ParserRule getRule() { return rule; }

		//MappingDeclarationCS | MappingDefinitionCS
		public Alternatives getAlternatives() { return cAlternatives; }

		//MappingDeclarationCS
		public RuleCall getMappingDeclarationCSParserRuleCall_0() { return cMappingDeclarationCSParserRuleCall_0; }

		//MappingDefinitionCS
		public RuleCall getMappingDefinitionCSParserRuleCall_1() { return cMappingDefinitionCSParserRuleCall_1; }
	}

	public class MappingDeclarationCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MappingDeclarationCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cMappingOperationHeaderCSParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Keyword cSemicolonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//MappingDeclarationCS returns MappingOperationCS:
		//	MappingOperationHeaderCS ";";
		@Override public ParserRule getRule() { return rule; }

		//MappingOperationHeaderCS ";"
		public Group getGroup() { return cGroup; }

		//MappingOperationHeaderCS
		public RuleCall getMappingOperationHeaderCSParserRuleCall_0() { return cMappingOperationHeaderCSParserRuleCall_0; }

		//";"
		public Keyword getSemicolonKeyword_1() { return cSemicolonKeyword_1; }
	}

	public class MappingDefinitionCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MappingDefinitionCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cMappingOperationHeaderCSParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cRightCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//MappingDefinitionCS returns MappingOperationCS:
		//	MappingOperationHeaderCS "{" "}";
		@Override public ParserRule getRule() { return rule; }

		//MappingOperationHeaderCS "{" "}"
		public Group getGroup() { return cGroup; }

		//MappingOperationHeaderCS
		public RuleCall getMappingOperationHeaderCSParserRuleCall_0() { return cMappingOperationHeaderCSParserRuleCall_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_2() { return cRightCurlyBracketKeyword_2; }
	}

	public class MappingOperationHeaderCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MappingOperationHeaderCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cQualifiersAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cQualifiersOperationQualifierParserRuleCall_0_0 = (RuleCall)cQualifiersAssignment_0.eContents().get(0);
		private final Keyword cMappingKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cDirectionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cDirectionDirectionKindCSEnumRuleCall_2_0 = (RuleCall)cDirectionAssignment_2.eContents().get(0);
		private final Assignment cScopedNameAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cScopedNamePathName2CSParserRuleCall_3_0 = (RuleCall)cScopedNameAssignment_3.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Assignment cOwnedParametersAssignment_5_0 = (Assignment)cGroup_5.eContents().get(0);
		private final RuleCall cOwnedParametersParameterDeclarationCSParserRuleCall_5_0_0 = (RuleCall)cOwnedParametersAssignment_5_0.eContents().get(0);
		private final Group cGroup_5_1 = (Group)cGroup_5.eContents().get(1);
		private final Keyword cCommaKeyword_5_1_0 = (Keyword)cGroup_5_1.eContents().get(0);
		private final Assignment cOwnedParametersAssignment_5_1_1 = (Assignment)cGroup_5_1.eContents().get(1);
		private final RuleCall cOwnedParametersParameterDeclarationCSParserRuleCall_5_1_1_0 = (RuleCall)cOwnedParametersAssignment_5_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Group cGroup_7 = (Group)cGroup.eContents().get(7);
		private final Keyword cColonKeyword_7_0 = (Keyword)cGroup_7.eContents().get(0);
		private final Assignment cResultsAssignment_7_1 = (Assignment)cGroup_7.eContents().get(1);
		private final RuleCall cResultsParameterDeclarationCSParserRuleCall_7_1_0 = (RuleCall)cResultsAssignment_7_1.eContents().get(0);
		private final Group cGroup_7_2 = (Group)cGroup_7.eContents().get(2);
		private final Keyword cCommaKeyword_7_2_0 = (Keyword)cGroup_7_2.eContents().get(0);
		private final Assignment cResultsAssignment_7_2_1 = (Assignment)cGroup_7_2.eContents().get(1);
		private final RuleCall cResultsParameterDeclarationCSParserRuleCall_7_2_1_0 = (RuleCall)cResultsAssignment_7_2_1.eContents().get(0);
		private final UnorderedGroup cUnorderedGroup_8 = (UnorderedGroup)cGroup.eContents().get(8);
		private final Group cGroup_8_0 = (Group)cUnorderedGroup_8.eContents().get(0);
		private final Keyword cInheritsKeyword_8_0_0 = (Keyword)cGroup_8_0.eContents().get(0);
		private final Assignment cInheritsAssignment_8_0_1 = (Assignment)cGroup_8_0.eContents().get(1);
		private final RuleCall cInheritsPathName2CSParserRuleCall_8_0_1_0 = (RuleCall)cInheritsAssignment_8_0_1.eContents().get(0);
		private final Group cGroup_8_0_2 = (Group)cGroup_8_0.eContents().get(2);
		private final Keyword cCommaKeyword_8_0_2_0 = (Keyword)cGroup_8_0_2.eContents().get(0);
		private final Assignment cInheritsAssignment_8_0_2_1 = (Assignment)cGroup_8_0_2.eContents().get(1);
		private final RuleCall cInheritsPathName2CSParserRuleCall_8_0_2_1_0 = (RuleCall)cInheritsAssignment_8_0_2_1.eContents().get(0);
		private final Group cGroup_8_1 = (Group)cUnorderedGroup_8.eContents().get(1);
		private final Keyword cMergesKeyword_8_1_0 = (Keyword)cGroup_8_1.eContents().get(0);
		private final Assignment cMergesAssignment_8_1_1 = (Assignment)cGroup_8_1.eContents().get(1);
		private final RuleCall cMergesPathName2CSParserRuleCall_8_1_1_0 = (RuleCall)cMergesAssignment_8_1_1.eContents().get(0);
		private final Group cGroup_8_1_2 = (Group)cGroup_8_1.eContents().get(2);
		private final Keyword cCommaKeyword_8_1_2_0 = (Keyword)cGroup_8_1_2.eContents().get(0);
		private final Assignment cMergesAssignment_8_1_2_1 = (Assignment)cGroup_8_1_2.eContents().get(1);
		private final RuleCall cMergesPathName2CSParserRuleCall_8_1_2_1_0 = (RuleCall)cMergesAssignment_8_1_2_1.eContents().get(0);
		private final Group cGroup_8_2 = (Group)cUnorderedGroup_8.eContents().get(2);
		private final Keyword cDisjunctsKeyword_8_2_0 = (Keyword)cGroup_8_2.eContents().get(0);
		private final Assignment cDisjunctsAssignment_8_2_1 = (Assignment)cGroup_8_2.eContents().get(1);
		private final RuleCall cDisjunctsPathName2CSParserRuleCall_8_2_1_0 = (RuleCall)cDisjunctsAssignment_8_2_1.eContents().get(0);
		private final Group cGroup_8_2_2 = (Group)cGroup_8_2.eContents().get(2);
		private final Keyword cCommaKeyword_8_2_2_0 = (Keyword)cGroup_8_2_2.eContents().get(0);
		private final Assignment cDisjunctsAssignment_8_2_2_1 = (Assignment)cGroup_8_2_2.eContents().get(1);
		private final RuleCall cDisjunctsPathName2CSParserRuleCall_8_2_2_1_0 = (RuleCall)cDisjunctsAssignment_8_2_2_1.eContents().get(0);
		private final Group cGroup_8_3 = (Group)cUnorderedGroup_8.eContents().get(3);
		private final Keyword cRefinesKeyword_8_3_0 = (Keyword)cGroup_8_3.eContents().get(0);
		private final Assignment cRefinesAssignment_8_3_1 = (Assignment)cGroup_8_3.eContents().get(1);
		private final RuleCall cRefinesPathName2CSParserRuleCall_8_3_1_0 = (RuleCall)cRefinesAssignment_8_3_1.eContents().get(0);
		private final Group cGroup_9 = (Group)cGroup.eContents().get(9);
		private final Keyword cWhenKeyword_9_0 = (Keyword)cGroup_9.eContents().get(0);
		private final Assignment cWhenAssignment_9_1 = (Assignment)cGroup_9.eContents().get(1);
		private final RuleCall cWhenBlockExpCSParserRuleCall_9_1_0 = (RuleCall)cWhenAssignment_9_1.eContents().get(0);
		private final Group cGroup_10 = (Group)cGroup.eContents().get(10);
		private final Keyword cWhereKeyword_10_0 = (Keyword)cGroup_10.eContents().get(0);
		private final Assignment cWhereAssignment_10_1 = (Assignment)cGroup_10.eContents().get(1);
		private final RuleCall cWhereBlockExpCSParserRuleCall_10_1_0 = (RuleCall)cWhereAssignment_10_1.eContents().get(0);
		
		//MappingOperationHeaderCS returns MappingOperationCS:
		//	qualifiers+=OperationQualifier* "mapping" direction=DirectionKindCS? scopedName=PathName2CS "("
		//	(ownedParameters+=ParameterDeclarationCS ("," ownedParameters+=ParameterDeclarationCS)*)? ")" (":"
		//	results+=ParameterDeclarationCS ("," results+=ParameterDeclarationCS))? (("inherits" inherits+=PathName2CS (","
		//	inherits+=PathName2CS)*)? & ("merges" merges+=PathName2CS ("," merges+=PathName2CS)*)? & ("disjuncts"
		//	disjuncts+=PathName2CS ("," disjuncts+=PathName2CS)*)? & ("refines" refines=PathName2CS)?) ("when" when=BlockExpCS)?
		//	("where" where=BlockExpCS)?;
		@Override public ParserRule getRule() { return rule; }

		//qualifiers+=OperationQualifier* "mapping" direction=DirectionKindCS? scopedName=PathName2CS "("
		//(ownedParameters+=ParameterDeclarationCS ("," ownedParameters+=ParameterDeclarationCS)*)? ")" (":"
		//results+=ParameterDeclarationCS ("," results+=ParameterDeclarationCS))? (("inherits" inherits+=PathName2CS (","
		//inherits+=PathName2CS)*)? & ("merges" merges+=PathName2CS ("," merges+=PathName2CS)*)? & ("disjuncts"
		//disjuncts+=PathName2CS ("," disjuncts+=PathName2CS)*)? & ("refines" refines=PathName2CS)?) ("when" when=BlockExpCS)?
		//("where" where=BlockExpCS)?
		public Group getGroup() { return cGroup; }

		//qualifiers+=OperationQualifier*
		public Assignment getQualifiersAssignment_0() { return cQualifiersAssignment_0; }

		//OperationQualifier
		public RuleCall getQualifiersOperationQualifierParserRuleCall_0_0() { return cQualifiersOperationQualifierParserRuleCall_0_0; }

		//"mapping"
		public Keyword getMappingKeyword_1() { return cMappingKeyword_1; }

		//direction=DirectionKindCS?
		public Assignment getDirectionAssignment_2() { return cDirectionAssignment_2; }

		//DirectionKindCS
		public RuleCall getDirectionDirectionKindCSEnumRuleCall_2_0() { return cDirectionDirectionKindCSEnumRuleCall_2_0; }

		//scopedName=PathName2CS
		public Assignment getScopedNameAssignment_3() { return cScopedNameAssignment_3; }

		//PathName2CS
		public RuleCall getScopedNamePathName2CSParserRuleCall_3_0() { return cScopedNamePathName2CSParserRuleCall_3_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_4() { return cLeftParenthesisKeyword_4; }

		//(ownedParameters+=ParameterDeclarationCS ("," ownedParameters+=ParameterDeclarationCS)*)?
		public Group getGroup_5() { return cGroup_5; }

		//ownedParameters+=ParameterDeclarationCS
		public Assignment getOwnedParametersAssignment_5_0() { return cOwnedParametersAssignment_5_0; }

		//ParameterDeclarationCS
		public RuleCall getOwnedParametersParameterDeclarationCSParserRuleCall_5_0_0() { return cOwnedParametersParameterDeclarationCSParserRuleCall_5_0_0; }

		//("," ownedParameters+=ParameterDeclarationCS)*
		public Group getGroup_5_1() { return cGroup_5_1; }

		//","
		public Keyword getCommaKeyword_5_1_0() { return cCommaKeyword_5_1_0; }

		//ownedParameters+=ParameterDeclarationCS
		public Assignment getOwnedParametersAssignment_5_1_1() { return cOwnedParametersAssignment_5_1_1; }

		//ParameterDeclarationCS
		public RuleCall getOwnedParametersParameterDeclarationCSParserRuleCall_5_1_1_0() { return cOwnedParametersParameterDeclarationCSParserRuleCall_5_1_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_6() { return cRightParenthesisKeyword_6; }

		//(":" results+=ParameterDeclarationCS ("," results+=ParameterDeclarationCS))?
		public Group getGroup_7() { return cGroup_7; }

		//":"
		public Keyword getColonKeyword_7_0() { return cColonKeyword_7_0; }

		//results+=ParameterDeclarationCS
		public Assignment getResultsAssignment_7_1() { return cResultsAssignment_7_1; }

		//ParameterDeclarationCS
		public RuleCall getResultsParameterDeclarationCSParserRuleCall_7_1_0() { return cResultsParameterDeclarationCSParserRuleCall_7_1_0; }

		//"," results+=ParameterDeclarationCS
		public Group getGroup_7_2() { return cGroup_7_2; }

		//","
		public Keyword getCommaKeyword_7_2_0() { return cCommaKeyword_7_2_0; }

		//results+=ParameterDeclarationCS
		public Assignment getResultsAssignment_7_2_1() { return cResultsAssignment_7_2_1; }

		//ParameterDeclarationCS
		public RuleCall getResultsParameterDeclarationCSParserRuleCall_7_2_1_0() { return cResultsParameterDeclarationCSParserRuleCall_7_2_1_0; }

		//("inherits" inherits+=PathName2CS ("," inherits+=PathName2CS)*)? & ("merges" merges+=PathName2CS (","
		//merges+=PathName2CS)*)? & ("disjuncts" disjuncts+=PathName2CS ("," disjuncts+=PathName2CS)*)? & ("refines"
		//refines=PathName2CS)?
		public UnorderedGroup getUnorderedGroup_8() { return cUnorderedGroup_8; }

		//("inherits" inherits+=PathName2CS ("," inherits+=PathName2CS)*)?
		public Group getGroup_8_0() { return cGroup_8_0; }

		//"inherits"
		public Keyword getInheritsKeyword_8_0_0() { return cInheritsKeyword_8_0_0; }

		//inherits+=PathName2CS
		public Assignment getInheritsAssignment_8_0_1() { return cInheritsAssignment_8_0_1; }

		//PathName2CS
		public RuleCall getInheritsPathName2CSParserRuleCall_8_0_1_0() { return cInheritsPathName2CSParserRuleCall_8_0_1_0; }

		//("," inherits+=PathName2CS)*
		public Group getGroup_8_0_2() { return cGroup_8_0_2; }

		//","
		public Keyword getCommaKeyword_8_0_2_0() { return cCommaKeyword_8_0_2_0; }

		//inherits+=PathName2CS
		public Assignment getInheritsAssignment_8_0_2_1() { return cInheritsAssignment_8_0_2_1; }

		//PathName2CS
		public RuleCall getInheritsPathName2CSParserRuleCall_8_0_2_1_0() { return cInheritsPathName2CSParserRuleCall_8_0_2_1_0; }

		//("merges" merges+=PathName2CS ("," merges+=PathName2CS)*)?
		public Group getGroup_8_1() { return cGroup_8_1; }

		//"merges"
		public Keyword getMergesKeyword_8_1_0() { return cMergesKeyword_8_1_0; }

		//merges+=PathName2CS
		public Assignment getMergesAssignment_8_1_1() { return cMergesAssignment_8_1_1; }

		//PathName2CS
		public RuleCall getMergesPathName2CSParserRuleCall_8_1_1_0() { return cMergesPathName2CSParserRuleCall_8_1_1_0; }

		//("," merges+=PathName2CS)*
		public Group getGroup_8_1_2() { return cGroup_8_1_2; }

		//","
		public Keyword getCommaKeyword_8_1_2_0() { return cCommaKeyword_8_1_2_0; }

		//merges+=PathName2CS
		public Assignment getMergesAssignment_8_1_2_1() { return cMergesAssignment_8_1_2_1; }

		//PathName2CS
		public RuleCall getMergesPathName2CSParserRuleCall_8_1_2_1_0() { return cMergesPathName2CSParserRuleCall_8_1_2_1_0; }

		//("disjuncts" disjuncts+=PathName2CS ("," disjuncts+=PathName2CS)*)?
		public Group getGroup_8_2() { return cGroup_8_2; }

		//"disjuncts"
		public Keyword getDisjunctsKeyword_8_2_0() { return cDisjunctsKeyword_8_2_0; }

		//disjuncts+=PathName2CS
		public Assignment getDisjunctsAssignment_8_2_1() { return cDisjunctsAssignment_8_2_1; }

		//PathName2CS
		public RuleCall getDisjunctsPathName2CSParserRuleCall_8_2_1_0() { return cDisjunctsPathName2CSParserRuleCall_8_2_1_0; }

		//("," disjuncts+=PathName2CS)*
		public Group getGroup_8_2_2() { return cGroup_8_2_2; }

		//","
		public Keyword getCommaKeyword_8_2_2_0() { return cCommaKeyword_8_2_2_0; }

		//disjuncts+=PathName2CS
		public Assignment getDisjunctsAssignment_8_2_2_1() { return cDisjunctsAssignment_8_2_2_1; }

		//PathName2CS
		public RuleCall getDisjunctsPathName2CSParserRuleCall_8_2_2_1_0() { return cDisjunctsPathName2CSParserRuleCall_8_2_2_1_0; }

		//("refines" refines=PathName2CS)?
		public Group getGroup_8_3() { return cGroup_8_3; }

		//"refines"
		public Keyword getRefinesKeyword_8_3_0() { return cRefinesKeyword_8_3_0; }

		//refines=PathName2CS
		public Assignment getRefinesAssignment_8_3_1() { return cRefinesAssignment_8_3_1; }

		//PathName2CS
		public RuleCall getRefinesPathName2CSParserRuleCall_8_3_1_0() { return cRefinesPathName2CSParserRuleCall_8_3_1_0; }

		//("when" when=BlockExpCS)?
		public Group getGroup_9() { return cGroup_9; }

		//"when"
		public Keyword getWhenKeyword_9_0() { return cWhenKeyword_9_0; }

		//when=BlockExpCS
		public Assignment getWhenAssignment_9_1() { return cWhenAssignment_9_1; }

		//BlockExpCS
		public RuleCall getWhenBlockExpCSParserRuleCall_9_1_0() { return cWhenBlockExpCSParserRuleCall_9_1_0; }

		//("where" where=BlockExpCS)?
		public Group getGroup_10() { return cGroup_10; }

		//"where"
		public Keyword getWhereKeyword_10_0() { return cWhereKeyword_10_0; }

		//where=BlockExpCS
		public Assignment getWhereAssignment_10_1() { return cWhereAssignment_10_1; }

		//BlockExpCS
		public RuleCall getWhereBlockExpCSParserRuleCall_10_1_0() { return cWhereBlockExpCSParserRuleCall_10_1_0; }
	}
	
	
	public class InitOpElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "InitOp");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cEQUALSEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cEQUALSEqualsSignKeyword_0_0 = (Keyword)cEQUALSEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cCOLON_EQUALSEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cCOLON_EQUALSColonEqualsSignKeyword_1_0 = (Keyword)cCOLON_EQUALSEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cCOLON_COLON_EQUALSEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cCOLON_COLON_EQUALSColonColonEqualsSignKeyword_2_0 = (Keyword)cCOLON_COLON_EQUALSEnumLiteralDeclaration_2.eContents().get(0);
		
		////enum ClassifierKind : DATATYPE='datatype' | PRIMITIVE='primitive' | EXCEPTION='exception' | CLASS='class';
		//
		////enum FeatureKey : COMPOSES='composes' | REFERRENCES='references' | READONLY='readonly' | DERIVED='derived' | STATIC='static';
		//
		//enum InitOp:
		//	EQUALS="=" | COLON_EQUALS=":=" | COLON_COLON_EQUALS="::=";
		public EnumRule getRule() { return rule; }

		//EQUALS="=" | COLON_EQUALS=":=" | COLON_COLON_EQUALS="::="
		public Alternatives getAlternatives() { return cAlternatives; }

		//EQUALS="="
		public EnumLiteralDeclaration getEQUALSEnumLiteralDeclaration_0() { return cEQUALSEnumLiteralDeclaration_0; }

		//"="
		public Keyword getEQUALSEqualsSignKeyword_0_0() { return cEQUALSEqualsSignKeyword_0_0; }

		//COLON_EQUALS=":="
		public EnumLiteralDeclaration getCOLON_EQUALSEnumLiteralDeclaration_1() { return cCOLON_EQUALSEnumLiteralDeclaration_1; }

		//":="
		public Keyword getCOLON_EQUALSColonEqualsSignKeyword_1_0() { return cCOLON_EQUALSColonEqualsSignKeyword_1_0; }

		//COLON_COLON_EQUALS="::="
		public EnumLiteralDeclaration getCOLON_COLON_EQUALSEnumLiteralDeclaration_2() { return cCOLON_COLON_EQUALSEnumLiteralDeclaration_2; }

		//"::="
		public Keyword getCOLON_COLON_EQUALSColonColonEqualsSignKeyword_2_0() { return cCOLON_COLON_EQUALSColonColonEqualsSignKeyword_2_0; }
	}

	public class MetamodelKindElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "MetamodelKind");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cMETAMODELEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cMETAMODELMetamodelKeyword_0_0 = (Keyword)cMETAMODELEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cPACKAGEEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cPACKAGEPackageKeyword_1_0 = (Keyword)cPACKAGEEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum MetamodelKind:
		//	METAMODEL="metamodel" | PACKAGE="package";
		public EnumRule getRule() { return rule; }

		//METAMODEL="metamodel" | PACKAGE="package"
		public Alternatives getAlternatives() { return cAlternatives; }

		//METAMODEL="metamodel"
		public EnumLiteralDeclaration getMETAMODELEnumLiteralDeclaration_0() { return cMETAMODELEnumLiteralDeclaration_0; }

		//"metamodel"
		public Keyword getMETAMODELMetamodelKeyword_0_0() { return cMETAMODELMetamodelKeyword_0_0; }

		//PACKAGE="package"
		public EnumLiteralDeclaration getPACKAGEEnumLiteralDeclaration_1() { return cPACKAGEEnumLiteralDeclaration_1; }

		//"package"
		public Keyword getPACKAGEPackageKeyword_1_0() { return cPACKAGEPackageKeyword_1_0; }
	}

	public class DirectionKindCSElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "DirectionKindCS");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cInEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cInInKeyword_0_0 = (Keyword)cInEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cOutEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cOutOutKeyword_1_0 = (Keyword)cOutEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cInoutEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cInoutInoutKeyword_2_0 = (Keyword)cInoutEnumLiteralDeclaration_2.eContents().get(0);
		
		//enum DirectionKindCS:
		//	in | out | inout;
		public EnumRule getRule() { return rule; }

		//in | out | inout
		public Alternatives getAlternatives() { return cAlternatives; }

		//in
		public EnumLiteralDeclaration getInEnumLiteralDeclaration_0() { return cInEnumLiteralDeclaration_0; }

		//"in"
		public Keyword getInInKeyword_0_0() { return cInInKeyword_0_0; }

		//out
		public EnumLiteralDeclaration getOutEnumLiteralDeclaration_1() { return cOutEnumLiteralDeclaration_1; }

		//"out"
		public Keyword getOutOutKeyword_1_0() { return cOutOutKeyword_1_0; }

		//inout
		public EnumLiteralDeclaration getInoutEnumLiteralDeclaration_2() { return cInoutEnumLiteralDeclaration_2; }

		//"inout"
		public Keyword getInoutInoutKeyword_2_0() { return cInoutInoutKeyword_2_0; }
	}

	public class ImportKindEnumElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "ImportKindEnum");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cAccessEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cAccessAccessKeyword_0_0 = (Keyword)cAccessEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cExtensionEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cExtensionExtendsKeyword_1_0 = (Keyword)cExtensionEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum ImportKindEnum:
		//	access | extension="extends";
		public EnumRule getRule() { return rule; }

		//access | extension="extends"
		public Alternatives getAlternatives() { return cAlternatives; }

		//access
		public EnumLiteralDeclaration getAccessEnumLiteralDeclaration_0() { return cAccessEnumLiteralDeclaration_0; }

		//"access"
		public Keyword getAccessAccessKeyword_0_0() { return cAccessAccessKeyword_0_0; }

		//extension="extends"
		public EnumLiteralDeclaration getExtensionEnumLiteralDeclaration_1() { return cExtensionEnumLiteralDeclaration_1; }

		//"extends"
		public Keyword getExtensionExtendsKeyword_1_0() { return cExtensionExtendsKeyword_1_0; }
	}

	public class ModuleKindEnumElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "ModuleKindEnum");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cLibraryEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cLibraryLibraryKeyword_0_0 = (Keyword)cLibraryEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cTransformationEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cTransformationTransformationKeyword_1_0 = (Keyword)cTransformationEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum ModuleKindEnum:
		//	library | transformation;
		public EnumRule getRule() { return rule; }

		//library | transformation
		public Alternatives getAlternatives() { return cAlternatives; }

		//library
		public EnumLiteralDeclaration getLibraryEnumLiteralDeclaration_0() { return cLibraryEnumLiteralDeclaration_0; }

		//"library"
		public Keyword getLibraryLibraryKeyword_0_0() { return cLibraryLibraryKeyword_0_0; }

		//transformation
		public EnumLiteralDeclaration getTransformationEnumLiteralDeclaration_1() { return cTransformationEnumLiteralDeclaration_1; }

		//"transformation"
		public Keyword getTransformationTransformationKeyword_1_0() { return cTransformationTransformationKeyword_1_0; }
	}
	
	private final TopLevelCSElements pTopLevelCS;
	private final InitOpElements unknownRuleInitOp;
	private final MetamodelKindElements unknownRuleMetamodelKind;
	private final DirectionKindCSElements unknownRuleDirectionKindCS;
	private final ImportKindEnumElements unknownRuleImportKindEnum;
	private final ModuleKindEnumElements unknownRuleModuleKindEnum;
	private final TransformationQualifierElements pTransformationQualifier;
	private final LibraryQualifierElements pLibraryQualifier;
	private final FeatureQualifierElements pFeatureQualifier;
	private final OperationQualifierElements pOperationQualifier;
	private final PathName2CSElements pPathName2CS;
	private final PathElement2CSElements pPathElement2CS;
	private final ImportCSElements pImportCS;
	private final UnitCSElements pUnitCS;
	private final UnitPackageCSElements pUnitPackageCS;
	private final UnitTypeCSElements pUnitTypeCS;
	private final ParameterCSElements pParameterCS;
	private final ParameterDeclarationCSElements pParameterDeclarationCS;
	private final InitPartCSElements pInitPartCS;
	private final TypeSpecCSElements pTypeSpecCS;
	private final MetamodelCSElements pMetamodelCS;
	private final ClassCSElements pClassCS;
	private final DataTypeCSElements pDataTypeCS;
	private final ExceptionCSElements pExceptionCS;
	private final QVToClassCSElements pQVToClassCS;
	private final TypedMultiplicityRef2CSElements pTypedMultiplicityRef2CS;
	private final TypeRef2CSElements pTypeRef2CS;
	private final TypedRef2CSElements pTypedRef2CS;
	private final TypedTypeRef2CSElements pTypedTypeRef2CS;
	private final ClassifierPropertyCSElements pClassifierPropertyCS;
	private final StereotypeQualifierCSElements pStereotypeQualifierCS;
	private final MultiplicityCSElements pMultiplicityCS;
	private final ClassifierOperationCSElements pClassifierOperationCS;
	private final EnumerationCSElements pEnumerationCS;
	private final EnumerationLiteralCSElements pEnumerationLiteralCS;
	private final TagCSElements pTagCS;
	private final ModuleRefCSElements pModuleRefCS;
	private final ModuleUsageCSElements pModuleUsageCS;
	private final TransformationCSElements pTransformationCS;
	private final TransformationDeclCSElements pTransformationDeclCS;
	private final TransformationDefCSElements pTransformationDefCS;
	private final TransformationHeaderCSElements pTransformationHeaderCS;
	private final LibraryCSElements pLibraryCS;
	private final LibraryDeclCSElements pLibraryDeclCS;
	private final LibraryDefCSElements pLibraryDefCS;
	private final LibraryHeaderCSElements pLibraryHeaderCS;
	private final ModelTypeCSElements pModelTypeCS;
	private final ModelTypeRefCSElements pModelTypeRefCS;
	private final PackageRefCSElements pPackageRefCS;
	private final ModulePropertyCSElements pModulePropertyCS;
	private final ModuleOperationCSElements pModuleOperationCS;
	private final MappingOperationCSElements pMappingOperationCS;
	private final MappingDeclarationCSElements pMappingDeclarationCS;
	private final MappingDefinitionCSElements pMappingDefinitionCS;
	private final MappingOperationHeaderCSElements pMappingOperationHeaderCS;
	
	private final Grammar grammar;

	private final ImperativeOCLGrammarAccess gaImperativeOCL;

	@Inject
	public QVTOperationalGrammarAccess(GrammarProvider grammarProvider,
		ImperativeOCLGrammarAccess gaImperativeOCL) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaImperativeOCL = gaImperativeOCL;
		this.pTopLevelCS = new TopLevelCSElements();
		this.unknownRuleInitOp = new InitOpElements();
		this.unknownRuleMetamodelKind = new MetamodelKindElements();
		this.unknownRuleDirectionKindCS = new DirectionKindCSElements();
		this.unknownRuleImportKindEnum = new ImportKindEnumElements();
		this.unknownRuleModuleKindEnum = new ModuleKindEnumElements();
		this.pTransformationQualifier = new TransformationQualifierElements();
		this.pLibraryQualifier = new LibraryQualifierElements();
		this.pFeatureQualifier = new FeatureQualifierElements();
		this.pOperationQualifier = new OperationQualifierElements();
		this.pPathName2CS = new PathName2CSElements();
		this.pPathElement2CS = new PathElement2CSElements();
		this.pImportCS = new ImportCSElements();
		this.pUnitCS = new UnitCSElements();
		this.pUnitPackageCS = new UnitPackageCSElements();
		this.pUnitTypeCS = new UnitTypeCSElements();
		this.pParameterCS = new ParameterCSElements();
		this.pParameterDeclarationCS = new ParameterDeclarationCSElements();
		this.pInitPartCS = new InitPartCSElements();
		this.pTypeSpecCS = new TypeSpecCSElements();
		this.pMetamodelCS = new MetamodelCSElements();
		this.pClassCS = new ClassCSElements();
		this.pDataTypeCS = new DataTypeCSElements();
		this.pExceptionCS = new ExceptionCSElements();
		this.pQVToClassCS = new QVToClassCSElements();
		this.pTypedMultiplicityRef2CS = new TypedMultiplicityRef2CSElements();
		this.pTypeRef2CS = new TypeRef2CSElements();
		this.pTypedRef2CS = new TypedRef2CSElements();
		this.pTypedTypeRef2CS = new TypedTypeRef2CSElements();
		this.pClassifierPropertyCS = new ClassifierPropertyCSElements();
		this.pStereotypeQualifierCS = new StereotypeQualifierCSElements();
		this.pMultiplicityCS = new MultiplicityCSElements();
		this.pClassifierOperationCS = new ClassifierOperationCSElements();
		this.pEnumerationCS = new EnumerationCSElements();
		this.pEnumerationLiteralCS = new EnumerationLiteralCSElements();
		this.pTagCS = new TagCSElements();
		this.pModuleRefCS = new ModuleRefCSElements();
		this.pModuleUsageCS = new ModuleUsageCSElements();
		this.pTransformationCS = new TransformationCSElements();
		this.pTransformationDeclCS = new TransformationDeclCSElements();
		this.pTransformationDefCS = new TransformationDefCSElements();
		this.pTransformationHeaderCS = new TransformationHeaderCSElements();
		this.pLibraryCS = new LibraryCSElements();
		this.pLibraryDeclCS = new LibraryDeclCSElements();
		this.pLibraryDefCS = new LibraryDefCSElements();
		this.pLibraryHeaderCS = new LibraryHeaderCSElements();
		this.pModelTypeCS = new ModelTypeCSElements();
		this.pModelTypeRefCS = new ModelTypeRefCSElements();
		this.pPackageRefCS = new PackageRefCSElements();
		this.pModulePropertyCS = new ModulePropertyCSElements();
		this.pModuleOperationCS = new ModuleOperationCSElements();
		this.pMappingOperationCS = new MappingOperationCSElements();
		this.pMappingDeclarationCS = new MappingDeclarationCSElements();
		this.pMappingDefinitionCS = new MappingDefinitionCSElements();
		this.pMappingOperationHeaderCS = new MappingOperationHeaderCSElements();
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.eclipse.qvto.examples.xtext.qvtoperational.QVTOperational".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	

	public ImperativeOCLGrammarAccess getImperativeOCLGrammarAccess() {
		return gaImperativeOCL;
	}

	
	//TopLevelCS:
	//	ownedImports+=ImportCS* (ownedPackages+=UnitPackageCS | ownedTypes+=UnitTypeCS)*;
	public TopLevelCSElements getTopLevelCSAccess() {
		return pTopLevelCS;
	}
	
	public ParserRule getTopLevelCSRule() {
		return getTopLevelCSAccess().getRule();
	}

	////enum ClassifierKind : DATATYPE='datatype' | PRIMITIVE='primitive' | EXCEPTION='exception' | CLASS='class';
	//
	////enum FeatureKey : COMPOSES='composes' | REFERRENCES='references' | READONLY='readonly' | DERIVED='derived' | STATIC='static';
	//
	//enum InitOp:
	//	EQUALS="=" | COLON_EQUALS=":=" | COLON_COLON_EQUALS="::=";
	public InitOpElements getInitOpAccess() {
		return unknownRuleInitOp;
	}
	
	public EnumRule getInitOpRule() {
		return getInitOpAccess().getRule();
	}

	//enum MetamodelKind:
	//	METAMODEL="metamodel" | PACKAGE="package";
	public MetamodelKindElements getMetamodelKindAccess() {
		return unknownRuleMetamodelKind;
	}
	
	public EnumRule getMetamodelKindRule() {
		return getMetamodelKindAccess().getRule();
	}

	//enum DirectionKindCS:
	//	in | out | inout;
	public DirectionKindCSElements getDirectionKindCSAccess() {
		return unknownRuleDirectionKindCS;
	}
	
	public EnumRule getDirectionKindCSRule() {
		return getDirectionKindCSAccess().getRule();
	}

	//enum ImportKindEnum:
	//	access | extension="extends";
	public ImportKindEnumElements getImportKindEnumAccess() {
		return unknownRuleImportKindEnum;
	}
	
	public EnumRule getImportKindEnumRule() {
		return getImportKindEnumAccess().getRule();
	}

	//enum ModuleKindEnum:
	//	library | transformation;
	public ModuleKindEnumElements getModuleKindEnumAccess() {
		return unknownRuleModuleKindEnum;
	}
	
	public EnumRule getModuleKindEnumRule() {
		return getModuleKindEnumAccess().getRule();
	}

	////enum ParamDirection : IN='in' | INOUT='inout' | OUT='out';
	// // FIXME use a CS element and unordered groups
	//
	//TransformationQualifier returns ecore::EString:
	//	"blackbox" | "abstract" | "static";
	public TransformationQualifierElements getTransformationQualifierAccess() {
		return pTransformationQualifier;
	}
	
	public ParserRule getTransformationQualifierRule() {
		return getTransformationQualifierAccess().getRule();
	}

	//LibraryQualifier returns ecore::EString:
	//	"blackbox";
	public LibraryQualifierElements getLibraryQualifierAccess() {
		return pLibraryQualifier;
	}
	
	public ParserRule getLibraryQualifierRule() {
		return getLibraryQualifierAccess().getRule();
	}

	//FeatureQualifier returns ecore::EString:
	//	"composes" | "references" | "readonly" | "derived" | "static";
	public FeatureQualifierElements getFeatureQualifierAccess() {
		return pFeatureQualifier;
	}
	
	public ParserRule getFeatureQualifierRule() {
		return getFeatureQualifierAccess().getRule();
	}

	//OperationQualifier returns ecore::EString:
	//	"blackbox";
	public OperationQualifierElements getOperationQualifierAccess() {
		return pOperationQualifier;
	}
	
	public ParserRule getOperationQualifierRule() {
		return getOperationQualifierAccess().getRule();
	}

	//// ****** OCL redifinitions ****** //
	// PathName2CS:
	//	ownedPathElements2+=PathElement2CS ("::" ownedPathElements2+=PathElement2CS)*;
	public PathName2CSElements getPathName2CSAccess() {
		return pPathName2CS;
	}
	
	public ParserRule getPathName2CSRule() {
		return getPathName2CSAccess().getRule();
	}

	//PathElement2CS:
	//	name=UnrestrictedName;
	public PathElement2CSElements getPathElement2CSAccess() {
		return pPathElement2CS;
	}
	
	public ParserRule getPathElement2CSRule() {
		return getPathElement2CSAccess().getRule();
	}

	//// ****** Imports ******
	// ImportCS returns QVToImportCS:
	//	"import" unit=UnitCS ";" | "from" unit=UnitCS "import" (importedUnitElement+=Identifier (","
	//	importedUnitElement+=Identifier)* | isAll?="*") ";";
	public ImportCSElements getImportCSAccess() {
		return pImportCS;
	}
	
	public ParserRule getImportCSRule() {
		return getImportCSAccess().getRule();
	}

	//UnitCS:
	//	segment+=Identifier ("." segment+=Identifier)*;
	public UnitCSElements getUnitCSAccess() {
		return pUnitCS;
	}
	
	public ParserRule getUnitCSRule() {
		return getUnitCSAccess().getRule();
	}

	//// ****** definitions in a compilation unit *******
	// UnitPackageCS returns base::PackageCS:
	//	MetamodelCS;
	public UnitPackageCSElements getUnitPackageCSAccess() {
		return pUnitPackageCS;
	}
	
	public ParserRule getUnitPackageCSRule() {
		return getUnitPackageCSAccess().getRule();
	}

	//UnitTypeCS returns base::TypeCS:
	//	ModelTypeCS | TransformationCS | LibraryCS;
	public UnitTypeCSElements getUnitTypeCSAccess() {
		return pUnitTypeCS;
	}
	
	public ParserRule getUnitTypeCSRule() {
		return getUnitTypeCSAccess().getRule();
	}

	//// ****** General rules ******
	//
	////CompleteSignatureCS: SimpleSignatureCS (':' (param+=ParameterCS (',' param+=ParameterCS)*))?;
	// //
	//
	////SimpleSignatureCS: {SimpleSignatureCS} 
	//
	////	'(' (parameter+=ParameterDeclarationCS (',' parameter+=ParameterDeclarationCS)*)? ')'
	// //;
	// ParameterCS returns
	//base::ParameterCS:
	//	name=UnrestrictedName (":" ownedType=TypedMultiplicityRef2CS)?;
	public ParameterCSElements getParameterCSAccess() {
		return pParameterCS;
	}
	
	public ParserRule getParameterCSRule() {
		return getParameterCSAccess().getRule();
	}

	//ParameterDeclarationCS:
	//	direction=DirectionKindCS? name= // FIXME Spec grammar says that you can have just a typeSpec
	// UnrestrictedName
	//	// TODO (':' ownedType=TypedMultiplicityRefCS)?
	// (":" ownedType=TypedMultiplicityRef2CS)? initPart=InitPartCS?;
	public ParameterDeclarationCSElements getParameterDeclarationCSAccess() {
		return pParameterDeclarationCS;
	}
	
	public ParserRule getParameterDeclarationCSRule() {
		return getParameterDeclarationCSAccess().getRule();
	}

	//// TODO also remove the corresponding CS metamodel element
	// //OperationSimpleSignatureCS : {OperationSimpleSignatureCS}
	//
	////	'(' (parameter+= OperationParameterDeclarationCS (',' parameter+= OperationParameterDeclarationCS)*)? ')'
	// //;
	//
	////OperationParameterDeclarationCS :
	// //	direction=DirectionKindCS? 
	//
	////	name=UnrestrictedName // FIXME Spec grammar says that you can have just a typeSpec  
	//
	////	(':' ownedType=TypeSpecCS)?
	// //	initPart=InitPartCS?
	// //;
	// InitPartCS:
	//	initOp=InitOp expression=ExpCS;
	public InitPartCSElements getInitPartCSAccess() {
		return pInitPartCS;
	}
	
	public ParserRule getInitPartCSRule() {
		return getInitPartCSAccess().getRule();
	}

	//TypeSpecCS:
	//	ownedType=TypedRefCS ("@" extentLocation=UnrestrictedName)?;
	public TypeSpecCSElements getTypeSpecCSAccess() {
		return pTypeSpecCS;
	}
	
	public ParserRule getTypeSpecCSRule() {
		return getTypeSpecCSAccess().getRule();
	}

	//// General rules END
	// // ****** Syntax for defining explicitly metamodel contents ******
	//
	//// MetamodelKind provides extra semantic, we need to retain the kind 
	// MetamodelCS:
	//	metamodelKind=MetamodelKind name=UnrestrictedName "{" (ownedClasses+=ClassCS
	//	// FIXME QVTo grammar distincts classifier from enumeration
	// | ownedClasses+=EnumerationCS |
	//	ownedAnnotations+=TagCS)* "}" ";"?;
	public MetamodelCSElements getMetamodelCSAccess() {
		return pMetamodelCS;
	}
	
	public ParserRule getMetamodelCSRule() {
		return getMetamodelCSAccess().getRule();
	}

	//ClassCS returns base::ClassCS:
	//	(DataTypeCS | ExceptionCS | QVToClassCS) ";"?;
	public ClassCSElements getClassCSAccess() {
		return pClassCS;
	}
	
	public ParserRule getClassCSRule() {
		return getClassCSAccess().getRule();
	}

	//DataTypeCS returns base::DataTypeCS:
	//	("datatype" | {PrimitiveTypeCS} "primitive") name=UnrestrictedName;
	public DataTypeCSElements getDataTypeCSAccess() {
		return pDataTypeCS;
	}
	
	public ParserRule getDataTypeCSRule() {
		return getDataTypeCSAccess().getRule();
	}

	//// FIXME so far, exception is another class
	// ExceptionCS returns base::StructuredClassCS:
	//	"exception" name=UnrestrictedName ("extends" (ownedSuperTypes+=TypedRefCS ("," ownedSuperTypes+=TypedRefCS)*))?;
	public ExceptionCSElements getExceptionCSAccess() {
		return pExceptionCS;
	}
	
	public ParserRule getExceptionCSRule() {
		return getExceptionCSAccess().getRule();
	}

	//QVToClassCS:
	//	intermediate?="intermediate"? // qualifier += Qualifier*
	// "class" name=UnrestrictedName ("extends"
	//	(ownedSuperTypes+=TypedRefCS ("," ownedSuperTypes+=TypedRefCS)*))? ("{" ((ownedProperties+=ClassifierPropertyCS |
	//	ownedOperations+=ClassifierOperationCS | ownedAnnotations+=TagCS) ";")+ "}")?;
	public QVToClassCSElements getQVToClassCSAccess() {
		return pQVToClassCS;
	}
	
	public ParserRule getQVToClassCSRule() {
		return getQVToClassCSAccess().getRule();
	}

	//TypedMultiplicityRef2CS returns base::TypedRefCS:
	//	TypedRef2CS ownedMultiplicity=MultiplicityCS?;
	public TypedMultiplicityRef2CSElements getTypedMultiplicityRef2CSAccess() {
		return pTypedMultiplicityRef2CS;
	}
	
	public ParserRule getTypedMultiplicityRef2CSRule() {
		return getTypedMultiplicityRef2CSAccess().getRule();
	}

	//// FIXME deviation from OCLInEcore. No templates parameter, yet
	// TypeRef2CS returns base::TypeRefCS:
	//// | WildcardTypeRefCS
	// TypedRef2CS;
	public TypeRef2CSElements getTypeRef2CSAccess() {
		return pTypeRef2CS;
	}
	
	public ParserRule getTypeRef2CSRule() {
		return getTypeRef2CSAccess().getRule();
	}

	//TypedRef2CS returns base::TypedRefCS:
	//	TypeLiteralCS | TypedTypeRef2CS;
	public TypedRef2CSElements getTypedRef2CSAccess() {
		return pTypedRef2CS;
	}
	
	public ParserRule getTypedRef2CSRule() {
		return getTypedRef2CSAccess().getRule();
	}

	//TypedTypeRef2CS:
	//	ownedPathName=PathName2CS ("(" ownedBinding=TemplateBindingCS ")")?;
	public TypedTypeRef2CSElements getTypedTypeRef2CSAccess() {
		return pTypedTypeRef2CS;
	}
	
	public ParserRule getTypedTypeRef2CSRule() {
		return getTypedTypeRef2CSAccess().getRule();
	}

	//ClassifierPropertyCS:
	//	stereotypes=StereotypeQualifierCS? qualifiers+=FeatureQualifier* name=UnrestrictedName ":"
	//	ownedType=TypedMultiplicityRef2CS default=SINGLE_QUOTED_STRING?
	//	// FIXME QVTO syntax define a more complex InitPartCS	
	// ("opposites" "~"? opposite=Identifier)? // FIXME 
	//;
	public ClassifierPropertyCSElements getClassifierPropertyCSAccess() {
		return pClassifierPropertyCS;
	}
	
	public ParserRule getClassifierPropertyCSRule() {
		return getClassifierPropertyCSAccess().getRule();
	}

	//StereotypeQualifierCS:
	//	"<<" (stereotype+=Identifier ("," stereotype+=Identifier)*) ">>";
	public StereotypeQualifierCSElements getStereotypeQualifierCSAccess() {
		return pStereotypeQualifierCS;
	}
	
	public ParserRule getStereotypeQualifierCSRule() {
		return getStereotypeQualifierCSAccess().getRule();
	}

	//MultiplicityCS returns base::MultiplicityBoundsCS:
	//	"[" (lowerBound=LOWER "...")? upperBound=UPPER "]";
	public MultiplicityCSElements getMultiplicityCSAccess() {
		return pMultiplicityCS;
	}
	
	public ParserRule getMultiplicityCSRule() {
		return getMultiplicityCSAccess().getRule();
	}

	//ClassifierOperationCS returns QVToOperationCS:
	//	stereotypes=StereotypeQualifierCS? qualifiers+=FeatureQualifier* name=UnrestrictedName "("
	//	(ownedParameters+=ParameterCS ("," ownedParameters+=ParameterCS)*)? ")" (":" ownedType=TypedMultiplicityRef2CS)?;
	public ClassifierOperationCSElements getClassifierOperationCSAccess() {
		return pClassifierOperationCS;
	}
	
	public ParserRule getClassifierOperationCSRule() {
		return getClassifierOperationCSAccess().getRule();
	}

	//// FIXME Deviation from official grammar
	// EnumerationCS returns base::EnumerationCS:
	//	"enum" name=Identifier ("{" (ownedLiterals+=EnumerationLiteralCS ("," ownedLiterals+=EnumerationLiteralCS)*) "}")
	//	";"?;
	public EnumerationCSElements getEnumerationCSAccess() {
		return pEnumerationCS;
	}
	
	public ParserRule getEnumerationCSRule() {
		return getEnumerationCSAccess().getRule();
	}

	//EnumerationLiteralCS returns base::EnumerationLiteralCS:
	//	name=UnrestrictedName;
	public EnumerationLiteralCSElements getEnumerationLiteralCSAccess() {
		return pEnumerationLiteralCS;
	}
	
	public ParserRule getEnumerationLiteralCSRule() {
		return getEnumerationLiteralCSAccess().getRule();
	}

	//TagCS:
	//	"tag" name=(UnrestrictedName | SINGLE_QUOTED_STRING)? elementPath=PathName2CS ("=" expression=ExpCS)? ";";
	public TagCSElements getTagCSAccess() {
		return pTagCS;
	}
	
	public ParserRule getTagCSRule() {
		return getTagCSAccess().getRule();
	}

	//// typedefs
	// // TypedefCS: 'typedef' name=Identifier '=' typespec=TypeExpCS ('[' condition=ExpCS ']')? ';';
	//
	//// ****** Transformation and Linbary imports
	// ModuleRefCS:
	//	modulePath=PathName2CS ("(" parameters+=ParameterDeclarationCS ("," parameters+=ParameterDeclarationCS)* ")")?;
	public ModuleRefCSElements getModuleRefCSAccess() {
		return pModuleRefCS;
	}
	
	public ParserRule getModuleRefCSRule() {
		return getModuleRefCSAccess().getRule();
	}

	//ModuleUsageCS:
	//	importKind=ImportKindEnum moduleKind=ModuleKindEnum? moduleRefs+=ModuleRefCS ("," moduleRefs+=ModuleRefCS)*;
	public ModuleUsageCSElements getModuleUsageCSAccess() {
		return pModuleUsageCS;
	}
	
	public ParserRule getModuleUsageCSRule() {
		return getModuleUsageCSAccess().getRule();
	}

	//// ****** Transformations, mappings, etc ******
	// TransformationCS:
	//	TransformationDeclCS | TransformationDefCS;
	public TransformationCSElements getTransformationCSAccess() {
		return pTransformationCS;
	}
	
	public ParserRule getTransformationCSRule() {
		return getTransformationCSAccess().getRule();
	}

	//TransformationDeclCS returns TransformationCS:
	//	TransformationHeaderCS ";";
	public TransformationDeclCSElements getTransformationDeclCSAccess() {
		return pTransformationDeclCS;
	}
	
	public ParserRule getTransformationDeclCSRule() {
		return getTransformationDeclCSAccess().getRule();
	}

	//TransformationDefCS returns TransformationCS:
	//	TransformationHeaderCS "{" (ownedProperties+=ModulePropertyCS
	//	// (ownedClasses+= ModuleTypeCS)* FIXME Transformation is not a package anymore. Not allowed
	// |
	//	ownedOperations+=ModuleOperationCS)* "}" ";"?;
	public TransformationDefCSElements getTransformationDefCSAccess() {
		return pTransformationDefCS;
	}
	
	public ParserRule getTransformationDefCSRule() {
		return getTransformationDefCSAccess().getRule();
	}

	//TransformationHeaderCS returns TransformationCS:
	//	qualifiers+=TransformationQualifier* "transformation" name=UnrestrictedName "(" parameters+=ParameterDeclarationCS
	//	("," parameters+=ParameterDeclarationCS)* ")" moduleUsages+=ModuleUsageCS* ("refines" refines=ModuleRefCS)?;
	public TransformationHeaderCSElements getTransformationHeaderCSAccess() {
		return pTransformationHeaderCS;
	}
	
	public ParserRule getTransformationHeaderCSRule() {
		return getTransformationHeaderCSAccess().getRule();
	}

	//LibraryCS returns QVToLibraryCS:
	//	LibraryDeclCS | LibraryDefCS;
	public LibraryCSElements getLibraryCSAccess() {
		return pLibraryCS;
	}
	
	public ParserRule getLibraryCSRule() {
		return getLibraryCSAccess().getRule();
	}

	//LibraryDeclCS returns QVToLibraryCS:
	//	LibraryHeaderCS ";";
	public LibraryDeclCSElements getLibraryDeclCSAccess() {
		return pLibraryDeclCS;
	}
	
	public ParserRule getLibraryDeclCSRule() {
		return getLibraryDeclCSAccess().getRule();
	}

	//LibraryDefCS returns QVToLibraryCS:
	//	LibraryHeaderCS "{" (ownedProperties+=ModulePropertyCS | ownedOperations+=ModuleOperationCS)* "}" ";"?;
	public LibraryDefCSElements getLibraryDefCSAccess() {
		return pLibraryDefCS;
	}
	
	public ParserRule getLibraryDefCSRule() {
		return getLibraryDefCSAccess().getRule();
	}

	//LibraryHeaderCS returns QVToLibraryCS:
	//	qualifiers+=LibraryQualifier* "library" name=UnrestrictedName "(" parameters+=ModelTypeRefCS (","
	//	parameters+=ModelTypeRefCS)* ")" moduleUsages+=ModuleUsageCS*;
	public LibraryHeaderCSElements getLibraryHeaderCSAccess() {
		return pLibraryHeaderCS;
	}
	
	public ParserRule getLibraryHeaderCSRule() {
		return getLibraryHeaderCSAccess().getRule();
	}

	//ModelTypeCS:
	//	"modeltype" name=UnrestrictedName complianceKind=StringLiteral? "uses" packageRefs+=PackageRefCS (","
	//	packageRefs+=PackageRefCS)* ("where" "{" / *TODO (whereStatements+=ExpCS (';' whereStatements+=ExpCS)* ';'?))? * /
	//	"}")? ";";
	public ModelTypeCSElements getModelTypeCSAccess() {
		return pModelTypeCS;
	}
	
	public ParserRule getModelTypeCSRule() {
		return getModelTypeCSAccess().getRule();
	}

	//ModelTypeRefCS:
	//	ownedType=TypedTypeRef2CS;
	public ModelTypeRefCSElements getModelTypeRefCSAccess() {
		return pModelTypeRefCS;
	}
	
	public ParserRule getModelTypeRefCSRule() {
		return getModelTypeRefCSAccess().getRule();
	}

	//PackageRefCS:
	//	uri=StringLiteralExpCS | packagePath=PathName2CS "(" uri=StringLiteralExpCS ")";
	public PackageRefCSElements getPackageRefCSAccess() {
		return pPackageRefCS;
	}
	
	public ParserRule getPackageRefCSRule() {
		return getPackageRefCSAccess().getRule();
	}

	//ModulePropertyCS returns base::StructuralFeatureCS:
	//	ClassifierPropertyCS;
	public ModulePropertyCSElements getModulePropertyCSAccess() {
		return pModulePropertyCS;
	}
	
	public ParserRule getModulePropertyCSRule() {
		return getModulePropertyCSAccess().getRule();
	}

	//ModuleOperationCS returns base::OperationCS:
	//	MappingOperationCS;
	public ModuleOperationCSElements getModuleOperationCSAccess() {
		return pModuleOperationCS;
	}
	
	public ParserRule getModuleOperationCSRule() {
		return getModuleOperationCSAccess().getRule();
	}

	//MappingOperationCS:
	//	MappingDeclarationCS | MappingDefinitionCS;
	public MappingOperationCSElements getMappingOperationCSAccess() {
		return pMappingOperationCS;
	}
	
	public ParserRule getMappingOperationCSRule() {
		return getMappingOperationCSAccess().getRule();
	}

	//MappingDeclarationCS returns MappingOperationCS:
	//	MappingOperationHeaderCS ";";
	public MappingDeclarationCSElements getMappingDeclarationCSAccess() {
		return pMappingDeclarationCS;
	}
	
	public ParserRule getMappingDeclarationCSRule() {
		return getMappingDeclarationCSAccess().getRule();
	}

	//MappingDefinitionCS returns MappingOperationCS:
	//	MappingOperationHeaderCS "{" "}";
	public MappingDefinitionCSElements getMappingDefinitionCSAccess() {
		return pMappingDefinitionCS;
	}
	
	public ParserRule getMappingDefinitionCSRule() {
		return getMappingDefinitionCSAccess().getRule();
	}

	//MappingOperationHeaderCS returns MappingOperationCS:
	//	qualifiers+=OperationQualifier* "mapping" direction=DirectionKindCS? scopedName=PathName2CS "("
	//	(ownedParameters+=ParameterDeclarationCS ("," ownedParameters+=ParameterDeclarationCS)*)? ")" (":"
	//	results+=ParameterDeclarationCS ("," results+=ParameterDeclarationCS))? (("inherits" inherits+=PathName2CS (","
	//	inherits+=PathName2CS)*)? & ("merges" merges+=PathName2CS ("," merges+=PathName2CS)*)? & ("disjuncts"
	//	disjuncts+=PathName2CS ("," disjuncts+=PathName2CS)*)? & ("refines" refines=PathName2CS)?) ("when" when=BlockExpCS)?
	//	("where" where=BlockExpCS)?;
	public MappingOperationHeaderCSElements getMappingOperationHeaderCSAccess() {
		return pMappingOperationHeaderCS;
	}
	
	public ParserRule getMappingOperationHeaderCSRule() {
		return getMappingOperationHeaderCSAccess().getRule();
	}

	//GrammmarCS returns essentialocl::ExpCS:
	//	ImperativeOCLExpCS;
	public ImperativeOCLGrammarAccess.GrammmarCSElements getGrammmarCSAccess() {
		return gaImperativeOCL.getGrammmarCSAccess();
	}
	
	public ParserRule getGrammmarCSRule() {
		return getGrammmarCSAccess().getRule();
	}

	//terminal ACCESS_OP:
	//	"." | "->" | "!->";
	public TerminalRule getACCESS_OPRule() {
		return gaImperativeOCL.getACCESS_OPRule();
	} 

	//// terminal ADD_OP: '+' | '-';
	// terminal ASSIGN_OP:
	//	":=" | "::=" | "+=" | "-=";
	public TerminalRule getASSIGN_OPRule() {
		return gaImperativeOCL.getASSIGN_OPRule();
	} 

	//terminal CMP_OP:
	//	"=" | "==" | "<>" | "<" | ">" | "<=" | ">=";
	public TerminalRule getCMP_OPRule() {
		return gaImperativeOCL.getCMP_OPRule();
	} 

	//terminal MULT_OP:
	//	"*" | "/" | "%";
	public TerminalRule getMULT_OPRule() {
		return gaImperativeOCL.getMULT_OPRule();
	} 

	//terminal MULTI_ITERATOR_OP:
	//	"forAll";
	public TerminalRule getMULTI_ITERATOR_OPRule() {
		return gaImperativeOCL.getMULTI_ITERATOR_OPRule();
	} 

	//// terminal OR_OP: 'or' | 'xor';
	// terminal RESOLVE_IN_KIND:
	//	"resolveIn" | "resolveoneIn" | "invresolveIn" | "invresolveoneIn";
	public TerminalRule getRESOLVE_IN_KINDRule() {
		return gaImperativeOCL.getRESOLVE_IN_KINDRule();
	} 

	//terminal RESOLVE_KIND:
	//	"resolve" | "resolveone" | "invresolve" | "invresolveone";
	public TerminalRule getRESOLVE_KINDRule() {
		return gaImperativeOCL.getRESOLVE_KINDRule();
	} 

	//terminal SIMPLE_ITERATOR_OP:
	//	"reject" | "select" | "collect" | "exists" | "one" | "any" | "isUnique" | "collectNested" | "sortedBy" | "xselect" |
	//	"xcollect" | "selectOne" | "collectOne" | "collectselect" | "collectselectOne";
	public TerminalRule getSIMPLE_ITERATOR_OPRule() {
		return gaImperativeOCL.getSIMPLE_ITERATOR_OPRule();
	} 

	//terminal UNARY_OP:
	//	"-" | "not" | "#" | "##" | "*";
	public TerminalRule getUNARY_OPRule() {
		return gaImperativeOCL.getUNARY_OPRule();
	} 

	//ImperativeOCLReservedKeyword:
	//	"default" | "elif" | RESOLVE_KIND | RESOLVE_IN_KIND;
	public ImperativeOCLGrammarAccess.ImperativeOCLReservedKeywordElements getImperativeOCLReservedKeywordAccess() {
		return gaImperativeOCL.getImperativeOCLReservedKeywordAccess();
	}
	
	public ParserRule getImperativeOCLReservedKeywordRule() {
		return getImperativeOCLReservedKeywordAccess().getRule();
	}

	//ImperativeOCLPrefixOperator:
	//	"#" | "##" | "*";
	public ImperativeOCLGrammarAccess.ImperativeOCLPrefixOperatorElements getImperativeOCLPrefixOperatorAccess() {
		return gaImperativeOCL.getImperativeOCLPrefixOperatorAccess();
	}
	
	public ParserRule getImperativeOCLPrefixOperatorRule() {
		return getImperativeOCLPrefixOperatorAccess().getRule();
	}

	//ImperativeOCLInfixOperator:
	//	ASSIGN_OP | "default" | "==";
	public ImperativeOCLGrammarAccess.ImperativeOCLInfixOperatorElements getImperativeOCLInfixOperatorAccess() {
		return gaImperativeOCL.getImperativeOCLInfixOperatorAccess();
	}
	
	public ParserRule getImperativeOCLInfixOperatorRule() {
		return getImperativeOCLInfixOperatorAccess().getRule();
	}

	//ImperativeOCLNavigationOperator:
	//	"!->";
	public ImperativeOCLGrammarAccess.ImperativeOCLNavigationOperatorElements getImperativeOCLNavigationOperatorAccess() {
		return gaImperativeOCL.getImperativeOCLNavigationOperatorAccess();
	}
	
	public ParserRule getImperativeOCLNavigationOperatorRule() {
		return getImperativeOCLNavigationOperatorAccess().getRule();
	}

	////PrefixOperator:
	// //	EssentialOCLPrefixOperator | QVToPrefixOperator;
	// //
	// //InfixOperator:
	//
	////	EssentialOCLInfixOperator | QVToInfixOperator;
	// //
	// //NavigationOperator:
	//
	////	EssentialOCLNavigationOperator | QVToNavigationOperator;
	// ImperativeOCLExpCS returns essentialocl::ExpCS:
	//	ExpCS;
	public ImperativeOCLGrammarAccess.ImperativeOCLExpCSElements getImperativeOCLExpCSAccess() {
		return gaImperativeOCL.getImperativeOCLExpCSAccess();
	}
	
	public ParserRule getImperativeOCLExpCSRule() {
		return getImperativeOCLExpCSAccess().getRule();
	}

	//// ********* ImperativeOCL Types *********
	// // TypeLiteralCS redefined to include the new List and Dict types
	//
	//// FIXME refactor its definition in EssentialOCL to allow extension
	// TypeLiteralCS returns base::TypedRefCS:
	//	PrimitiveTypeCS | CollectionTypeCS | MapTypeCS | TupleTypeCS | ListTypeCS | DictTypeCS;
	public ImperativeOCLGrammarAccess.TypeLiteralCSElements getTypeLiteralCSAccess() {
		return gaImperativeOCL.getTypeLiteralCSAccess();
	}
	
	public ParserRule getTypeLiteralCSRule() {
		return getTypeLiteralCSAccess().getRule();
	}

	//ListTypeCS:
	//	"List" "(" type=TypeExpCS ")";
	public ImperativeOCLGrammarAccess.ListTypeCSElements getListTypeCSAccess() {
		return gaImperativeOCL.getListTypeCSAccess();
	}
	
	public ParserRule getListTypeCSRule() {
		return getListTypeCSAccess().getRule();
	}

	//DictTypeCS:
	//	"Dict" "(" keyType=TypeExpCS "," valueType=TypeExpCS ")";
	public ImperativeOCLGrammarAccess.DictTypeCSElements getDictTypeCSAccess() {
		return gaImperativeOCL.getDictTypeCSAccess();
	}
	
	public ParserRule getDictTypeCSRule() {
		return getDictTypeCSAccess().getRule();
	}

	//// ********* ImperativeOCL Expressions *********
	//
	//// PrimaryExpCS redefined to include the new List and Dict literal expressions
	//
	//// FIXME refactor its definition in EssentialOCL to allow extension
	// // These rules are ordered most rejectable first
	//
	//PrimaryExpCS returns essentialocl::ExpCS:
	//	NestedExpCS | IfExpCS | SelfExpCS | PrimitiveLiteralExpCS | TupleLiteralExpCS | MapLiteralExpCS |
	//	CollectionLiteralExpCS | LambdaLiteralExpCS | ListLiteralExpCS | DictLiteralExpCS | TypeLiteralExpCS | ReturnExpCS |
	//	NameExpCS;
	public ImperativeOCLGrammarAccess.PrimaryExpCSElements getPrimaryExpCSAccess() {
		return gaImperativeOCL.getPrimaryExpCSAccess();
	}
	
	public ParserRule getPrimaryExpCSRule() {
		return getPrimaryExpCSAccess().getRule();
	}

	//ListLiteralExpCS:
	//	"List" "{" {ListLiteralExpCS} (ownedParts+=CollectionLiteralPartCS ("," ownedParts+=CollectionLiteralPartCS)*)? "}";
	public ImperativeOCLGrammarAccess.ListLiteralExpCSElements getListLiteralExpCSAccess() {
		return gaImperativeOCL.getListLiteralExpCSAccess();
	}
	
	public ParserRule getListLiteralExpCSRule() {
		return getListLiteralExpCSAccess().getRule();
	}

	//DictLiteralExpCS:
	//	"Dict" "{" {DictLiteralExpCS} (ownedParts+=DictLiteralPartCS ("," ownedParts+=DictLiteralPartCS)*)? "}";
	public ImperativeOCLGrammarAccess.DictLiteralExpCSElements getDictLiteralExpCSAccess() {
		return gaImperativeOCL.getDictLiteralExpCSAccess();
	}
	
	public ParserRule getDictLiteralExpCSRule() {
		return getDictLiteralExpCSAccess().getRule();
	}

	//DictLiteralPartCS:
	//	key=PrimitiveLiteralExpCS "=" value=ExpCS;
	public ImperativeOCLGrammarAccess.DictLiteralPartCSElements getDictLiteralPartCSAccess() {
		return gaImperativeOCL.getDictLiteralPartCSAccess();
	}
	
	public ParserRule getDictLiteralPartCSRule() {
		return getDictLiteralPartCSAccess().getRule();
	}

	//ReturnExpCS:
	//	"return" {ReturnExpCS} value=ExpCS?;
	public ImperativeOCLGrammarAccess.ReturnExpCSElements getReturnExpCSAccess() {
		return gaImperativeOCL.getReturnExpCSAccess();
	}
	
	public ParserRule getReturnExpCSRule() {
		return getReturnExpCSAccess().getRule();
	}

	//BlockExpCS:
	//	"{" expressions+=ExpCS "}";
	public ImperativeOCLGrammarAccess.BlockExpCSElements getBlockExpCSAccess() {
		return gaImperativeOCL.getBlockExpCSAccess();
	}
	
	public ParserRule getBlockExpCSRule() {
		return getBlockExpCSAccess().getRule();
	}

	//StringLiteral:
	//	SINGLE_QUOTED_STRING | DOUBLE_QUOTED_STRING;
	public ImperativeOCLGrammarAccess.StringLiteralElements getStringLiteralAccess() {
		return gaImperativeOCL.getStringLiteralAccess();
	}
	
	public ParserRule getStringLiteralRule() {
		return getStringLiteralAccess().getRule();
	}

	////generate essentialOCLCST "http://www.eclipse.org/ocl/3.0.0/EssentialOCLCST"
	// Model returns ContextCS:
	//	ownedExpression=ExpCS;
	public EssentialOCLGrammarAccess.ModelElements getModelAccess() {
		return gaImperativeOCL.getModelAccess();
	}
	
	public ParserRule getModelRule() {
		return getModelAccess().getRule();
	}

	/// ** <<<This is a join point for derived grammars - replace with a more disciplined grammar extensibility>>> * /
	//EssentialOCLReservedKeyword:
	//	"and" | "else" | "endif" | "if" | "implies" | "in" | "let" | "not" | "or" | "then" | "xor";
	public EssentialOCLGrammarAccess.EssentialOCLReservedKeywordElements getEssentialOCLReservedKeywordAccess() {
		return gaImperativeOCL.getEssentialOCLReservedKeywordAccess();
	}
	
	public ParserRule getEssentialOCLReservedKeywordRule() {
		return getEssentialOCLReservedKeywordAccess().getRule();
	}

	/// ** <<<This is a join point for derived grammars - replace with a more disciplined grammar extensibility>>> * /
	//EssentialOCLUnaryOperatorName:
	//	"-" | "not";
	public EssentialOCLGrammarAccess.EssentialOCLUnaryOperatorNameElements getEssentialOCLUnaryOperatorNameAccess() {
		return gaImperativeOCL.getEssentialOCLUnaryOperatorNameAccess();
	}
	
	public ParserRule getEssentialOCLUnaryOperatorNameRule() {
		return getEssentialOCLUnaryOperatorNameAccess().getRule();
	}

	/// ** <<<This is a join point for derived grammars - replace with a more disciplined grammar extensibility>>> * /
	//EssentialOCLInfixOperatorName:
	//	"*" | "/" | "+" | "-" | ">" | "<" | ">=" | "<=" | "=" | "<>" | "and" | "or" | "xor" | "implies";
	public EssentialOCLGrammarAccess.EssentialOCLInfixOperatorNameElements getEssentialOCLInfixOperatorNameAccess() {
		return gaImperativeOCL.getEssentialOCLInfixOperatorNameAccess();
	}
	
	public ParserRule getEssentialOCLInfixOperatorNameRule() {
		return getEssentialOCLInfixOperatorNameAccess().getRule();
	}

	/// ** <<<This is a join point for derived grammars - replace with a more disciplined grammar extensibility>>> * /
	//EssentialOCLNavigationOperatorName:
	//	"." | "->" | "?." | "?->";
	public EssentialOCLGrammarAccess.EssentialOCLNavigationOperatorNameElements getEssentialOCLNavigationOperatorNameAccess() {
		return gaImperativeOCL.getEssentialOCLNavigationOperatorNameAccess();
	}
	
	public ParserRule getEssentialOCLNavigationOperatorNameRule() {
		return getEssentialOCLNavigationOperatorNameAccess().getRule();
	}

	//BinaryOperatorName:
	//	InfixOperatorName | NavigationOperatorName;
	public EssentialOCLGrammarAccess.BinaryOperatorNameElements getBinaryOperatorNameAccess() {
		return gaImperativeOCL.getBinaryOperatorNameAccess();
	}
	
	public ParserRule getBinaryOperatorNameRule() {
		return getBinaryOperatorNameAccess().getRule();
	}

	//// Intended to be overrideable
	// InfixOperatorName:
	//	EssentialOCLInfixOperatorName;
	public EssentialOCLGrammarAccess.InfixOperatorNameElements getInfixOperatorNameAccess() {
		return gaImperativeOCL.getInfixOperatorNameAccess();
	}
	
	public ParserRule getInfixOperatorNameRule() {
		return getInfixOperatorNameAccess().getRule();
	}

	//// Intended to be overrideable
	// NavigationOperatorName:
	//	EssentialOCLNavigationOperatorName;
	public EssentialOCLGrammarAccess.NavigationOperatorNameElements getNavigationOperatorNameAccess() {
		return gaImperativeOCL.getNavigationOperatorNameAccess();
	}
	
	public ParserRule getNavigationOperatorNameRule() {
		return getNavigationOperatorNameAccess().getRule();
	}

	//// Intended to be overrideable
	// UnaryOperatorName:
	//	EssentialOCLUnaryOperatorName;
	public EssentialOCLGrammarAccess.UnaryOperatorNameElements getUnaryOperatorNameAccess() {
		return gaImperativeOCL.getUnaryOperatorNameAccess();
	}
	
	public ParserRule getUnaryOperatorNameRule() {
		return getUnaryOperatorNameAccess().getRule();
	}

	////---------------------------------------------------------------------
	// //  Names
	//
	////---------------------------------------------------------------------
	//
	/// ** <<<This is a join point for derived grammars - replace with a more disciplined grammar extensibility>>> * /
	//EssentialOCLUnrestrictedName returns ecore::EString:
	//	Identifier;
	public EssentialOCLGrammarAccess.EssentialOCLUnrestrictedNameElements getEssentialOCLUnrestrictedNameAccess() {
		return gaImperativeOCL.getEssentialOCLUnrestrictedNameAccess();
	}
	
	public ParserRule getEssentialOCLUnrestrictedNameRule() {
		return getEssentialOCLUnrestrictedNameAccess().getRule();
	}

	//// Intended to be overridden
	// UnrestrictedName returns ecore::EString:
	//	EssentialOCLUnrestrictedName;
	public EssentialOCLGrammarAccess.UnrestrictedNameElements getUnrestrictedNameAccess() {
		return gaImperativeOCL.getUnrestrictedNameAccess();
	}
	
	public ParserRule getUnrestrictedNameRule() {
		return getUnrestrictedNameAccess().getRule();
	}

	/// ** <<<This is a join point for derived grammars - replace with a more disciplined grammar extensibility>>> * /
	//EssentialOCLUnreservedName returns ecore::EString:
	//	UnrestrictedName | CollectionTypeIdentifier | PrimitiveTypeIdentifier | "Map" | "Tuple";
	public EssentialOCLGrammarAccess.EssentialOCLUnreservedNameElements getEssentialOCLUnreservedNameAccess() {
		return gaImperativeOCL.getEssentialOCLUnreservedNameAccess();
	}
	
	public ParserRule getEssentialOCLUnreservedNameRule() {
		return getEssentialOCLUnreservedNameAccess().getRule();
	}

	//// Intended to be overridden
	// UnreservedName returns ecore::EString:
	//	EssentialOCLUnreservedName;
	public EssentialOCLGrammarAccess.UnreservedNameElements getUnreservedNameAccess() {
		return gaImperativeOCL.getUnreservedNameAccess();
	}
	
	public ParserRule getUnreservedNameRule() {
		return getUnreservedNameAccess().getRule();
	}

	//URIPathNameCS returns base::PathNameCS:
	//	ownedPathElements+=URIFirstPathElementCS ("::" ownedPathElements+=NextPathElementCS)*;
	public EssentialOCLGrammarAccess.URIPathNameCSElements getURIPathNameCSAccess() {
		return gaImperativeOCL.getURIPathNameCSAccess();
	}
	
	public ParserRule getURIPathNameCSRule() {
		return getURIPathNameCSAccess().getRule();
	}

	//URIFirstPathElementCS returns base::PathElementCS:
	//	referredElement=[pivot::NamedElement|UnrestrictedName] | {base::PathElementWithURICS}
	//	referredElement=[pivot::Namespace|URI];
	public EssentialOCLGrammarAccess.URIFirstPathElementCSElements getURIFirstPathElementCSAccess() {
		return gaImperativeOCL.getURIFirstPathElementCSAccess();
	}
	
	public ParserRule getURIFirstPathElementCSRule() {
		return getURIFirstPathElementCSAccess().getRule();
	}

	////---------------------------------------------------------------------
	// //  Types
	//
	////---------------------------------------------------------------------
	// PrimitiveTypeIdentifier:
	//	"Boolean" | "Integer" | "Real" | "String" | "UnlimitedNatural" | "OclAny" | "OclInvalid" | "OclVoid";
	public EssentialOCLGrammarAccess.PrimitiveTypeIdentifierElements getPrimitiveTypeIdentifierAccess() {
		return gaImperativeOCL.getPrimitiveTypeIdentifierAccess();
	}
	
	public ParserRule getPrimitiveTypeIdentifierRule() {
		return getPrimitiveTypeIdentifierAccess().getRule();
	}

	//PrimitiveTypeCS returns base::PrimitiveTypeRefCS:
	//	name=PrimitiveTypeIdentifier;
	public EssentialOCLGrammarAccess.PrimitiveTypeCSElements getPrimitiveTypeCSAccess() {
		return gaImperativeOCL.getPrimitiveTypeCSAccess();
	}
	
	public ParserRule getPrimitiveTypeCSRule() {
		return getPrimitiveTypeCSAccess().getRule();
	}

	//CollectionTypeIdentifier returns ecore::EString:
	//	"Set" | "Bag" | "Sequence" | "Collection" | "OrderedSet";
	public EssentialOCLGrammarAccess.CollectionTypeIdentifierElements getCollectionTypeIdentifierAccess() {
		return gaImperativeOCL.getCollectionTypeIdentifierAccess();
	}
	
	public ParserRule getCollectionTypeIdentifierRule() {
		return getCollectionTypeIdentifierAccess().getRule();
	}

	//CollectionTypeCS:
	//	name=CollectionTypeIdentifier ("(" ownedType=TypeExpCS ")")?;
	public EssentialOCLGrammarAccess.CollectionTypeCSElements getCollectionTypeCSAccess() {
		return gaImperativeOCL.getCollectionTypeCSAccess();
	}
	
	public ParserRule getCollectionTypeCSRule() {
		return getCollectionTypeCSAccess().getRule();
	}

	//MapTypeCS:
	//	name="Map" ("(" ownedKeyType=TypeExpCS "," ownedValueType=TypeExpCS ")")?;
	public EssentialOCLGrammarAccess.MapTypeCSElements getMapTypeCSAccess() {
		return gaImperativeOCL.getMapTypeCSAccess();
	}
	
	public ParserRule getMapTypeCSRule() {
		return getMapTypeCSAccess().getRule();
	}

	//TupleTypeCS returns base::TupleTypeCS:
	//	name="Tuple" ("(" (ownedParts+=TuplePartCS ("," ownedParts+=TuplePartCS)*)? ")")?;
	public EssentialOCLGrammarAccess.TupleTypeCSElements getTupleTypeCSAccess() {
		return gaImperativeOCL.getTupleTypeCSAccess();
	}
	
	public ParserRule getTupleTypeCSRule() {
		return getTupleTypeCSAccess().getRule();
	}

	//TuplePartCS returns base::TuplePartCS:
	//	name=UnrestrictedName ":" ownedType=TypeExpCS;
	public EssentialOCLGrammarAccess.TuplePartCSElements getTuplePartCSAccess() {
		return gaImperativeOCL.getTuplePartCSAccess();
	}
	
	public ParserRule getTuplePartCSRule() {
		return getTuplePartCSAccess().getRule();
	}

	////---------------------------------------------------------------------
	// //  Literals
	//
	////---------------------------------------------------------------------
	// CollectionLiteralExpCS:
	//	ownedType=CollectionTypeCS "{" (ownedParts+=CollectionLiteralPartCS ("," ownedParts+=CollectionLiteralPartCS)*)? "}";
	public EssentialOCLGrammarAccess.CollectionLiteralExpCSElements getCollectionLiteralExpCSAccess() {
		return gaImperativeOCL.getCollectionLiteralExpCSAccess();
	}
	
	public ParserRule getCollectionLiteralExpCSRule() {
		return getCollectionLiteralExpCSAccess().getRule();
	}

	//CollectionLiteralPartCS:
	//	ownedExpression=ExpCS (".." ownedLastExpression=ExpCS)? | ownedExpression=PatternExpCS;
	public EssentialOCLGrammarAccess.CollectionLiteralPartCSElements getCollectionLiteralPartCSAccess() {
		return gaImperativeOCL.getCollectionLiteralPartCSAccess();
	}
	
	public ParserRule getCollectionLiteralPartCSRule() {
		return getCollectionLiteralPartCSAccess().getRule();
	}

	//CollectionPatternCS:
	//	ownedType=CollectionTypeCS "{" (ownedParts+=PatternExpCS ("," ownedParts+=PatternExpCS)* ("++"
	//	restVariableName=Identifier))? "}";
	public EssentialOCLGrammarAccess.CollectionPatternCSElements getCollectionPatternCSAccess() {
		return gaImperativeOCL.getCollectionPatternCSAccess();
	}
	
	public ParserRule getCollectionPatternCSRule() {
		return getCollectionPatternCSAccess().getRule();
	}

	//// PatternPartCS
	// ShadowPartCS:
	//	referredProperty=[pivot::Property|UnrestrictedName] "=" ownedInitExpression=(ExpCS | PatternExpCS);
	public EssentialOCLGrammarAccess.ShadowPartCSElements getShadowPartCSAccess() {
		return gaImperativeOCL.getShadowPartCSAccess();
	}
	
	public ParserRule getShadowPartCSRule() {
		return getShadowPartCSAccess().getRule();
	}

	//PatternExpCS:
	//	patternVariableName=UnrestrictedName? ":" ownedPatternType=TypeExpCS;
	public EssentialOCLGrammarAccess.PatternExpCSElements getPatternExpCSAccess() {
		return gaImperativeOCL.getPatternExpCSAccess();
	}
	
	public ParserRule getPatternExpCSRule() {
		return getPatternExpCSAccess().getRule();
	}

	//LambdaLiteralExpCS:
	//	"Lambda" "{" ownedExpressionCS=ExpCS "}";
	public EssentialOCLGrammarAccess.LambdaLiteralExpCSElements getLambdaLiteralExpCSAccess() {
		return gaImperativeOCL.getLambdaLiteralExpCSAccess();
	}
	
	public ParserRule getLambdaLiteralExpCSRule() {
		return getLambdaLiteralExpCSAccess().getRule();
	}

	//MapLiteralExpCS:
	//	ownedType=MapTypeCS "{" (ownedParts+=MapLiteralPartCS ("," ownedParts+=MapLiteralPartCS)*)? "}";
	public EssentialOCLGrammarAccess.MapLiteralExpCSElements getMapLiteralExpCSAccess() {
		return gaImperativeOCL.getMapLiteralExpCSAccess();
	}
	
	public ParserRule getMapLiteralExpCSRule() {
		return getMapLiteralExpCSAccess().getRule();
	}

	//MapLiteralPartCS:
	//	ownedKey=ExpCS "<-" ownedValue=ExpCS;
	public EssentialOCLGrammarAccess.MapLiteralPartCSElements getMapLiteralPartCSAccess() {
		return gaImperativeOCL.getMapLiteralPartCSAccess();
	}
	
	public ParserRule getMapLiteralPartCSRule() {
		return getMapLiteralPartCSAccess().getRule();
	}

	//PrimitiveLiteralExpCS:
	//	NumberLiteralExpCS | StringLiteralExpCS | BooleanLiteralExpCS | UnlimitedNaturalLiteralExpCS | InvalidLiteralExpCS |
	//	NullLiteralExpCS;
	public EssentialOCLGrammarAccess.PrimitiveLiteralExpCSElements getPrimitiveLiteralExpCSAccess() {
		return gaImperativeOCL.getPrimitiveLiteralExpCSAccess();
	}
	
	public ParserRule getPrimitiveLiteralExpCSRule() {
		return getPrimitiveLiteralExpCSAccess().getRule();
	}

	//TupleLiteralExpCS:
	//	"Tuple" "{" ownedParts+=TupleLiteralPartCS ("," ownedParts+=TupleLiteralPartCS)* "}";
	public EssentialOCLGrammarAccess.TupleLiteralExpCSElements getTupleLiteralExpCSAccess() {
		return gaImperativeOCL.getTupleLiteralExpCSAccess();
	}
	
	public ParserRule getTupleLiteralExpCSRule() {
		return getTupleLiteralExpCSAccess().getRule();
	}

	//TupleLiteralPartCS:
	//	name=UnrestrictedName (":" ownedType=TypeExpCS)? "=" ownedInitExpression=ExpCS;
	public EssentialOCLGrammarAccess.TupleLiteralPartCSElements getTupleLiteralPartCSAccess() {
		return gaImperativeOCL.getTupleLiteralPartCSAccess();
	}
	
	public ParserRule getTupleLiteralPartCSRule() {
		return getTupleLiteralPartCSAccess().getRule();
	}

	//NumberLiteralExpCS:
	//	symbol=NUMBER_LITERAL;
	public EssentialOCLGrammarAccess.NumberLiteralExpCSElements getNumberLiteralExpCSAccess() {
		return gaImperativeOCL.getNumberLiteralExpCSAccess();
	}
	
	public ParserRule getNumberLiteralExpCSRule() {
		return getNumberLiteralExpCSAccess().getRule();
	}

	//StringLiteralExpCS:
	//	segments+=StringLiteral+;
	public EssentialOCLGrammarAccess.StringLiteralExpCSElements getStringLiteralExpCSAccess() {
		return gaImperativeOCL.getStringLiteralExpCSAccess();
	}
	
	public ParserRule getStringLiteralExpCSRule() {
		return getStringLiteralExpCSAccess().getRule();
	}

	//BooleanLiteralExpCS:
	//	symbol="true" | symbol="false";
	public EssentialOCLGrammarAccess.BooleanLiteralExpCSElements getBooleanLiteralExpCSAccess() {
		return gaImperativeOCL.getBooleanLiteralExpCSAccess();
	}
	
	public ParserRule getBooleanLiteralExpCSRule() {
		return getBooleanLiteralExpCSAccess().getRule();
	}

	//UnlimitedNaturalLiteralExpCS:
	//	{UnlimitedNaturalLiteralExpCS} "*";
	public EssentialOCLGrammarAccess.UnlimitedNaturalLiteralExpCSElements getUnlimitedNaturalLiteralExpCSAccess() {
		return gaImperativeOCL.getUnlimitedNaturalLiteralExpCSAccess();
	}
	
	public ParserRule getUnlimitedNaturalLiteralExpCSRule() {
		return getUnlimitedNaturalLiteralExpCSAccess().getRule();
	}

	//InvalidLiteralExpCS:
	//	{InvalidLiteralExpCS} "invalid";
	public EssentialOCLGrammarAccess.InvalidLiteralExpCSElements getInvalidLiteralExpCSAccess() {
		return gaImperativeOCL.getInvalidLiteralExpCSAccess();
	}
	
	public ParserRule getInvalidLiteralExpCSRule() {
		return getInvalidLiteralExpCSAccess().getRule();
	}

	//NullLiteralExpCS:
	//	{NullLiteralExpCS} "null";
	public EssentialOCLGrammarAccess.NullLiteralExpCSElements getNullLiteralExpCSAccess() {
		return gaImperativeOCL.getNullLiteralExpCSAccess();
	}
	
	public ParserRule getNullLiteralExpCSRule() {
		return getNullLiteralExpCSAccess().getRule();
	}

	//TypeLiteralWithMultiplicityCS returns base::TypedRefCS:
	//	TypeLiteralCS ownedMultiplicity=MultiplicityCS?;
	public EssentialOCLGrammarAccess.TypeLiteralWithMultiplicityCSElements getTypeLiteralWithMultiplicityCSAccess() {
		return gaImperativeOCL.getTypeLiteralWithMultiplicityCSAccess();
	}
	
	public ParserRule getTypeLiteralWithMultiplicityCSRule() {
		return getTypeLiteralWithMultiplicityCSAccess().getRule();
	}

	//TypeLiteralExpCS:
	//	ownedType=TypeLiteralWithMultiplicityCS;
	public EssentialOCLGrammarAccess.TypeLiteralExpCSElements getTypeLiteralExpCSAccess() {
		return gaImperativeOCL.getTypeLiteralExpCSAccess();
	}
	
	public ParserRule getTypeLiteralExpCSRule() {
		return getTypeLiteralExpCSAccess().getRule();
	}

	//TypeNameExpCS:
	//	ownedPathName=PathNameCS (ownedCurlyBracketedClause=CurlyBracketedClauseCS ("{" ownedPatternGuard=ExpCS "}")?)?;
	public EssentialOCLGrammarAccess.TypeNameExpCSElements getTypeNameExpCSAccess() {
		return gaImperativeOCL.getTypeNameExpCSAccess();
	}
	
	public ParserRule getTypeNameExpCSRule() {
		return getTypeNameExpCSAccess().getRule();
	}

	//TypeExpCS returns base::TypedRefCS:
	//	(TypeNameExpCS | TypeLiteralCS | CollectionPatternCS) ownedMultiplicity=MultiplicityCS?;
	public EssentialOCLGrammarAccess.TypeExpCSElements getTypeExpCSAccess() {
		return gaImperativeOCL.getTypeExpCSAccess();
	}
	
	public ParserRule getTypeExpCSRule() {
		return getTypeExpCSAccess().getRule();
	}

	////---------------------------------------------------------------------
	// //  Expressions
	//
	////---------------------------------------------------------------------
	//
	//// An ExpCS permits a LetExpCS only in the final term to ensure
	//
	////  that let is right associative, whereas infix operators are left associative.
	//
	////   a = 64 / 16 / let b : Integer in 8 / let c : Integer in 4 
	// // is
	//
	////   a = (64 / 16) / (let b : Integer in 8 / (let c : Integer in 4 ))
	//
	/// * An expression elaborates a prefixed expression with zero or more binary operator and expression suffixes.
	// * An optionally prefixed let expression is permitted except when suffixed with further expressions.* /
	//ExpCS:
	//	PrefixedPrimaryExpCS ({InfixExpCS.ownedLeft=current} name=BinaryOperatorName ownedRight=ExpCS)?
	//	//	({InfixExpCS} ownedSource=PrefixedExpCS name=BinaryOperatorName ownedArgument=ExpCS)
	// //| 	PrefixedExpCS
	//
	//	// the above takes exponential or worse time for backtracking, below is fast
	// | PrefixedLetExpCS;
	public EssentialOCLGrammarAccess.ExpCSElements getExpCSAccess() {
		return gaImperativeOCL.getExpCSAccess();
	}
	
	public ParserRule getExpCSRule() {
		return getExpCSAccess().getRule();
	}

	/// * A prefixed let expression elaborates a let expression with zero or more unary prefix operators. * / PrefixedLetExpCS
	//returns ExpCS:
	//	{PrefixExpCS} name=UnaryOperatorName ownedRight=PrefixedLetExpCS | LetExpCS;
	public EssentialOCLGrammarAccess.PrefixedLetExpCSElements getPrefixedLetExpCSAccess() {
		return gaImperativeOCL.getPrefixedLetExpCSAccess();
	}
	
	public ParserRule getPrefixedLetExpCSRule() {
		return getPrefixedLetExpCSAccess().getRule();
	}

	/// * A prefixed primary expression elaborates a primary expression with zero or more unary prefix operators. * /
	//PrefixedPrimaryExpCS returns ExpCS:
	//	{PrefixExpCS} name=UnaryOperatorName ownedRight=PrefixedPrimaryExpCS | PrimaryExpCS;
	public EssentialOCLGrammarAccess.PrefixedPrimaryExpCSElements getPrefixedPrimaryExpCSAccess() {
		return gaImperativeOCL.getPrefixedPrimaryExpCSAccess();
	}
	
	public ParserRule getPrefixedPrimaryExpCSRule() {
		return getPrefixedPrimaryExpCSAccess().getRule();
	}

	/// * A name expression is a generalised rule for expressions that start with a name and which may be followed by square, round or
	// * curly bracket clauses and optionally an @pre as well.* /
	//NameExpCS:
	//	ownedPathName=PathNameCS ownedSquareBracketedClauses+=SquareBracketedClauseCS*
	//	ownedRoundBracketedClause=RoundBracketedClauseCS? ownedCurlyBracketedClause=CurlyBracketedClauseCS? (isPre?="@"
	//	"pre")?;
	public EssentialOCLGrammarAccess.NameExpCSElements getNameExpCSAccess() {
		return gaImperativeOCL.getNameExpCSAccess();
	}
	
	public ParserRule getNameExpCSRule() {
		return getNameExpCSAccess().getRule();
	}

	/// * A curly bracket clause is a generalized rule for the literal arguments of collections, maps, tuples and shadows.* /
	//CurlyBracketedClauseCS:
	//	{CurlyBracketedClauseCS} "{" ((ownedParts+=ShadowPartCS ("," ownedParts+=ShadowPartCS)*)? | value=StringLiteral) "}";
	public EssentialOCLGrammarAccess.CurlyBracketedClauseCSElements getCurlyBracketedClauseCSAccess() {
		return gaImperativeOCL.getCurlyBracketedClauseCSAccess();
	}
	
	public ParserRule getCurlyBracketedClauseCSRule() {
		return getCurlyBracketedClauseCSAccess().getRule();
	}

	/// * A curly bracket clause is a generalized rule for template specialisations and operations arguments.* /
	//RoundBracketedClauseCS:
	//	{RoundBracketedClauseCS} "(" (ownedArguments+=NavigatingArgCS ownedArguments+=NavigatingCommaArgCS*
	//	(ownedArguments+=NavigatingSemiArgCS ownedArguments+=NavigatingCommaArgCS*)? (ownedArguments+=NavigatingBarArgCS
	//	ownedArguments+=NavigatingCommaArgCS*)*)? ")";
	public EssentialOCLGrammarAccess.RoundBracketedClauseCSElements getRoundBracketedClauseCSAccess() {
		return gaImperativeOCL.getRoundBracketedClauseCSAccess();
	}
	
	public ParserRule getRoundBracketedClauseCSRule() {
		return getRoundBracketedClauseCSAccess().getRule();
	}

	/// * A square bracket clause is a generalized rule for association class qualifiers and roles.* / SquareBracketedClauseCS:
	//	"[" ownedTerms+=ExpCS ("," ownedTerms+=ExpCS)* "]";
	public EssentialOCLGrammarAccess.SquareBracketedClauseCSElements getSquareBracketedClauseCSAccess() {
		return gaImperativeOCL.getSquareBracketedClauseCSAccess();
	}
	
	public ParserRule getSquareBracketedClauseCSRule() {
		return getSquareBracketedClauseCSAccess().getRule();
	}

	/// * A navigating argument is a generalized rule for the first argument in a round bracket clause. This is typically the first operation
	// * parameter or an iterator. * /
	//// Type-less init is an illegal infix expression
	// NavigatingArgCS:
	//	ownedNameExpression=NavigatingArgExpCS (":" ownedType=TypeExpCS ("=" ownedInitExpression=ExpCS)? | "in"
	//	ownedInitExpression=ExpCS)? | ":" ownedType=TypeExpCS;
	public EssentialOCLGrammarAccess.NavigatingArgCSElements getNavigatingArgCSAccess() {
		return gaImperativeOCL.getNavigatingArgCSAccess();
	}
	
	public ParserRule getNavigatingArgCSRule() {
		return getNavigatingArgCSAccess().getRule();
	}

	/// * A navigating bar argument is a generalized rule for a bar-prefixed argument in a round bracket clause. This is typically the body of an iteration. * /
	//// Type-less init is an illegal infix expression
	// NavigatingBarArgCS returns NavigatingArgCS:
	//	prefix="|" ownedNameExpression=NavigatingArgExpCS (":" ownedType=TypeExpCS ("=" ownedInitExpression=ExpCS)?)?;
	public EssentialOCLGrammarAccess.NavigatingBarArgCSElements getNavigatingBarArgCSAccess() {
		return gaImperativeOCL.getNavigatingBarArgCSAccess();
	}
	
	public ParserRule getNavigatingBarArgCSRule() {
		return getNavigatingBarArgCSAccess().getRule();
	}

	/// * A navigating comma argument is a generalized rule for non-first argument in a round bracket clause. These are typically non-first operation
	// * parameters or a second iterator. * /
	//// Type-less init is an illegal infix expression
	// NavigatingCommaArgCS returns NavigatingArgCS:
	//	prefix="," ownedNameExpression=NavigatingArgExpCS (":" ownedType=TypeExpCS ("=" ownedInitExpression=ExpCS)? | "in"
	//	ownedInitExpression=ExpCS)?;
	public EssentialOCLGrammarAccess.NavigatingCommaArgCSElements getNavigatingCommaArgCSAccess() {
		return gaImperativeOCL.getNavigatingCommaArgCSAccess();
	}
	
	public ParserRule getNavigatingCommaArgCSRule() {
		return getNavigatingCommaArgCSAccess().getRule();
	}

	/// * A navigating semi argument is a generalized rule for a semicolon prefixed argument in a round bracket clause. This is typically an iterate accumulator. * /
	//// Type-less init is an illegal infix expression
	// NavigatingSemiArgCS returns NavigatingArgCS:
	//	prefix=";" ownedNameExpression=NavigatingArgExpCS (":" ownedType=TypeExpCS ("=" ownedInitExpression=ExpCS)?)?;
	public EssentialOCLGrammarAccess.NavigatingSemiArgCSElements getNavigatingSemiArgCSAccess() {
		return gaImperativeOCL.getNavigatingSemiArgCSAccess();
	}
	
	public ParserRule getNavigatingSemiArgCSRule() {
		return getNavigatingSemiArgCSAccess().getRule();
	}

	//// Intended to be overridden
	// //	'?'	-- defined by Complete OCL
	// NavigatingArgExpCS returns ExpCS:
	//	ExpCS;
	public EssentialOCLGrammarAccess.NavigatingArgExpCSElements getNavigatingArgExpCSAccess() {
		return gaImperativeOCL.getNavigatingArgExpCSAccess();
	}
	
	public ParserRule getNavigatingArgExpCSRule() {
		return getNavigatingArgExpCSAccess().getRule();
	}

	//IfExpCS:
	//	"if" ownedCondition=(ExpCS | PatternExpCS) "then" ownedThenExpression=ExpCS //	ifThenExpressions+=IfThenExpCS
	//
	//	ownedIfThenExpressions+=ElseIfThenExpCS* "else" ownedElseExpression=ExpCS "endif";
	public EssentialOCLGrammarAccess.IfExpCSElements getIfExpCSAccess() {
		return gaImperativeOCL.getIfExpCSAccess();
	}
	
	public ParserRule getIfExpCSRule() {
		return getIfExpCSAccess().getRule();
	}

	////IfThenExpCS returns IfThenExpCS:
	// //	'if' condition=ExpCS
	// //	'then' thenExpression=ExpCS
	// //;
	// ElseIfThenExpCS
	//returns IfThenExpCS:
	//	"elseif" ownedCondition=ExpCS "then" ownedThenExpression=ExpCS;
	public EssentialOCLGrammarAccess.ElseIfThenExpCSElements getElseIfThenExpCSAccess() {
		return gaImperativeOCL.getElseIfThenExpCSAccess();
	}
	
	public ParserRule getElseIfThenExpCSRule() {
		return getElseIfThenExpCSAccess().getRule();
	}

	//LetExpCS:
	//	"let" ownedVariables+=LetVariableCS ("," ownedVariables+=LetVariableCS)* "in" ownedInExpression=ExpCS;
	public EssentialOCLGrammarAccess.LetExpCSElements getLetExpCSAccess() {
		return gaImperativeOCL.getLetExpCSAccess();
	}
	
	public ParserRule getLetExpCSRule() {
		return getLetExpCSAccess().getRule();
	}

	//LetVariableCS:
	//	name=UnrestrictedName ownedRoundBracketedClause=RoundBracketedClauseCS? (":" ownedType=TypeExpCS)? "="
	//	ownedInitExpression=ExpCS;
	public EssentialOCLGrammarAccess.LetVariableCSElements getLetVariableCSAccess() {
		return gaImperativeOCL.getLetVariableCSAccess();
	}
	
	public ParserRule getLetVariableCSRule() {
		return getLetVariableCSAccess().getRule();
	}

	//NestedExpCS:
	//	"(" ownedExpression=ExpCS ")";
	public EssentialOCLGrammarAccess.NestedExpCSElements getNestedExpCSAccess() {
		return gaImperativeOCL.getNestedExpCSAccess();
	}
	
	public ParserRule getNestedExpCSRule() {
		return getNestedExpCSAccess().getRule();
	}

	//SelfExpCS:
	//	{SelfExpCS} "self";
	public EssentialOCLGrammarAccess.SelfExpCSElements getSelfExpCSAccess() {
		return gaImperativeOCL.getSelfExpCSAccess();
	}
	
	public ParserRule getSelfExpCSRule() {
		return getSelfExpCSAccess().getRule();
	}

	//MultiplicityBoundsCS:
	//	lowerBound=LOWER (".." upperBound=UPPER)?;
	public BaseGrammarAccess.MultiplicityBoundsCSElements getMultiplicityBoundsCSAccess() {
		return gaImperativeOCL.getMultiplicityBoundsCSAccess();
	}
	
	public ParserRule getMultiplicityBoundsCSRule() {
		return getMultiplicityBoundsCSAccess().getRule();
	}

	//MultiplicityStringCS:
	//	stringBounds=("*" | "+" | "?");
	public BaseGrammarAccess.MultiplicityStringCSElements getMultiplicityStringCSAccess() {
		return gaImperativeOCL.getMultiplicityStringCSAccess();
	}
	
	public ParserRule getMultiplicityStringCSRule() {
		return getMultiplicityStringCSAccess().getRule();
	}

	//PathNameCS:
	//	ownedPathElements+=FirstPathElementCS ("::" ownedPathElements+=NextPathElementCS)*;
	public BaseGrammarAccess.PathNameCSElements getPathNameCSAccess() {
		return gaImperativeOCL.getPathNameCSAccess();
	}
	
	public ParserRule getPathNameCSRule() {
		return getPathNameCSAccess().getRule();
	}

	//FirstPathElementCS returns PathElementCS:
	//	referredElement=[pivot::NamedElement|UnrestrictedName];
	public BaseGrammarAccess.FirstPathElementCSElements getFirstPathElementCSAccess() {
		return gaImperativeOCL.getFirstPathElementCSAccess();
	}
	
	public ParserRule getFirstPathElementCSRule() {
		return getFirstPathElementCSAccess().getRule();
	}

	//NextPathElementCS returns PathElementCS:
	//	referredElement=[pivot::NamedElement|UnreservedName];
	public BaseGrammarAccess.NextPathElementCSElements getNextPathElementCSAccess() {
		return gaImperativeOCL.getNextPathElementCSAccess();
	}
	
	public ParserRule getNextPathElementCSRule() {
		return getNextPathElementCSAccess().getRule();
	}

	//TemplateBindingCS:
	//	ownedSubstitutions+=TemplateParameterSubstitutionCS ("," ownedSubstitutions+=TemplateParameterSubstitutionCS)*
	//	ownedMultiplicity=MultiplicityCS?;
	public BaseGrammarAccess.TemplateBindingCSElements getTemplateBindingCSAccess() {
		return gaImperativeOCL.getTemplateBindingCSAccess();
	}
	
	public ParserRule getTemplateBindingCSRule() {
		return getTemplateBindingCSAccess().getRule();
	}

	//TemplateParameterSubstitutionCS:
	//	ownedActualParameter=TypeRefCS;
	public BaseGrammarAccess.TemplateParameterSubstitutionCSElements getTemplateParameterSubstitutionCSAccess() {
		return gaImperativeOCL.getTemplateParameterSubstitutionCSAccess();
	}
	
	public ParserRule getTemplateParameterSubstitutionCSRule() {
		return getTemplateParameterSubstitutionCSAccess().getRule();
	}

	//TemplateSignatureCS:
	//	"(" ownedParameters+=TypeParameterCS ("," ownedParameters+=TypeParameterCS)* ")";
	public BaseGrammarAccess.TemplateSignatureCSElements getTemplateSignatureCSAccess() {
		return gaImperativeOCL.getTemplateSignatureCSAccess();
	}
	
	public ParserRule getTemplateSignatureCSRule() {
		return getTemplateSignatureCSAccess().getRule();
	}

	//TypeParameterCS:
	//	name=UnrestrictedName ("extends" ownedExtends+=TypedRefCS ("&&" ownedExtends+=TypedRefCS)*)?;
	public BaseGrammarAccess.TypeParameterCSElements getTypeParameterCSAccess() {
		return gaImperativeOCL.getTypeParameterCSAccess();
	}
	
	public ParserRule getTypeParameterCSRule() {
		return getTypeParameterCSAccess().getRule();
	}

	//TypeRefCS:
	//	TypedRefCS | WildcardTypeRefCS;
	public BaseGrammarAccess.TypeRefCSElements getTypeRefCSAccess() {
		return gaImperativeOCL.getTypeRefCSAccess();
	}
	
	public ParserRule getTypeRefCSRule() {
		return getTypeRefCSAccess().getRule();
	}

	//TypedRefCS:
	//	TypedTypeRefCS;
	public BaseGrammarAccess.TypedRefCSElements getTypedRefCSAccess() {
		return gaImperativeOCL.getTypedRefCSAccess();
	}
	
	public ParserRule getTypedRefCSRule() {
		return getTypedRefCSAccess().getRule();
	}

	//TypedTypeRefCS:
	//	ownedPathName=PathNameCS ("(" ownedBinding=TemplateBindingCS ")")?;
	public BaseGrammarAccess.TypedTypeRefCSElements getTypedTypeRefCSAccess() {
		return gaImperativeOCL.getTypedTypeRefCSAccess();
	}
	
	public ParserRule getTypedTypeRefCSRule() {
		return getTypedTypeRefCSAccess().getRule();
	}

	//WildcardTypeRefCS:
	//	{WildcardTypeRefCS} "?" ("extends" ownedExtends=TypedRefCS)?;
	public BaseGrammarAccess.WildcardTypeRefCSElements getWildcardTypeRefCSAccess() {
		return gaImperativeOCL.getWildcardTypeRefCSAccess();
	}
	
	public ParserRule getWildcardTypeRefCSRule() {
		return getWildcardTypeRefCSAccess().getRule();
	}

	//ID:
	//	SIMPLE_ID | ESCAPED_ID;
	public BaseGrammarAccess.IDElements getIDAccess() {
		return gaImperativeOCL.getIDAccess();
	}
	
	public ParserRule getIDRule() {
		return getIDAccess().getRule();
	}

	//Identifier:
	//	ID;
	public BaseGrammarAccess.IdentifierElements getIdentifierAccess() {
		return gaImperativeOCL.getIdentifierAccess();
	}
	
	public ParserRule getIdentifierRule() {
		return getIdentifierAccess().getRule();
	}

	/// * A lowerbounded integer is used to define the lowerbound of a collection multiplicity. The value may not be the unlimited value. * /
	//LOWER returns ecore::EInt:
	//	INT;
	public BaseGrammarAccess.LOWERElements getLOWERAccess() {
		return gaImperativeOCL.getLOWERAccess();
	}
	
	public ParserRule getLOWERRule() {
		return getLOWERAccess().getRule();
	}

	/// * A number may be an integer or floating point value. The declaration here appears to be that for just an integer. This is to avoid
	// * lookahead conflicts in simple lexers between a dot within a floating point number and the dot-dot in a CollectionLiteralPartCS. A
	// * practical implementation should give high priority to a successful parse of INT ('.' INT)? (('e' | 'E') ('+' | '-')? INT)? than
	// * to the unsuccessful partial parse of INT '..'. The type of the INT terminal is String to allow the floating point syntax to be used.
	// * /
	//// Not terminal to allow parser backtracking to sort out "5..7"
	//
	//// EssentialOCLTokenSource pieces this together ('.' INT)? (('e' | 'E') ('+' | '-')? INT)?;
	// NUMBER_LITERAL returns
	//BigNumber:
	//	INT;
	public BaseGrammarAccess.NUMBER_LITERALElements getNUMBER_LITERALAccess() {
		return gaImperativeOCL.getNUMBER_LITERALAccess();
	}
	
	public ParserRule getNUMBER_LITERALRule() {
		return getNUMBER_LITERALAccess().getRule();
	}

	/// * An upperbounded integer is used to define the upperbound of a collection multiplicity. The value may be the unlimited value. * /
	//UPPER returns ecore::EInt:
	//	INT | "*";
	public BaseGrammarAccess.UPPERElements getUPPERAccess() {
		return gaImperativeOCL.getUPPERAccess();
	}
	
	public ParserRule getUPPERRule() {
		return getUPPERAccess().getRule();
	}

	//URI:
	//	SINGLE_QUOTED_STRING;
	public BaseGrammarAccess.URIElements getURIAccess() {
		return gaImperativeOCL.getURIAccess();
	}
	
	public ParserRule getURIRule() {
		return getURIAccess().getRule();
	}

	//terminal fragment ESCAPED_CHARACTER:
	//	"\\" ("b" | "t" | "n" | "f" | "r" | "u" | "\"" | "\'" | "\\");
	public TerminalRule getESCAPED_CHARACTERRule() {
		return gaImperativeOCL.getESCAPED_CHARACTERRule();
	} 

	//terminal fragment LETTER_CHARACTER:
	//	"a".."z" | "A".."Z" | "_";
	public TerminalRule getLETTER_CHARACTERRule() {
		return gaImperativeOCL.getLETTER_CHARACTERRule();
	} 

	//terminal DOUBLE_QUOTED_STRING:
	//	"\"" (ESCAPED_CHARACTER | !("\\" | "\""))* "\"";
	public TerminalRule getDOUBLE_QUOTED_STRINGRule() {
		return gaImperativeOCL.getDOUBLE_QUOTED_STRINGRule();
	} 

	//terminal SINGLE_QUOTED_STRING:
	//	"\'" (ESCAPED_CHARACTER | !("\\" | "\'"))* "\'";
	public TerminalRule getSINGLE_QUOTED_STRINGRule() {
		return gaImperativeOCL.getSINGLE_QUOTED_STRINGRule();
	} 

	//terminal ML_SINGLE_QUOTED_STRING:
	//	"/\'"->"\'/";
	public TerminalRule getML_SINGLE_QUOTED_STRINGRule() {
		return gaImperativeOCL.getML_SINGLE_QUOTED_STRINGRule();
	} 

	//terminal SIMPLE_ID:
	//	LETTER_CHARACTER (LETTER_CHARACTER | "0".."9")*;
	public TerminalRule getSIMPLE_IDRule() {
		return gaImperativeOCL.getSIMPLE_IDRule();
	} 

	//terminal ESCAPED_ID:
	//	"_" SINGLE_QUOTED_STRING;
	public TerminalRule getESCAPED_IDRule() {
		return gaImperativeOCL.getESCAPED_IDRule();
	} 

	//// String to allow diverse re-use
	// // multiple leading zeroes occur as floating point fractional part
	// terminal INT:
	//	"0".."9"+;
	public TerminalRule getINTRule() {
		return gaImperativeOCL.getINTRule();
	} 

	/// * A multi-line comment supports a comment that may span more than one line using familiar slash-star...star-slash comment delimiters * /
	//terminal ML_COMMENT:
	//	"/ *"->"* /";
	public TerminalRule getML_COMMENTRule() {
		return gaImperativeOCL.getML_COMMENTRule();
	} 

	/// * A single-line comment supports a comment that terminates at the end of the line * / terminal SL_COMMENT:
	//	"--" !("\n" | "\r")* ("\r"? "\n")?;
	public TerminalRule getSL_COMMENTRule() {
		return gaImperativeOCL.getSL_COMMENTRule();
	} 

	/// * Whitespace may occur between any pair of tokens * / terminal WS:
	//	(" " | "\t" | "\r" | "\n")+;
	public TerminalRule getWSRule() {
		return gaImperativeOCL.getWSRule();
	} 

	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaImperativeOCL.getANY_OTHERRule();
	} 
}
